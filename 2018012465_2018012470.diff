diff --git a/Memory/.bazeliskrc b/Memory/.bazeliskrc
index f81d3f7..2159662 100644
--- a/Memory/.bazeliskrc
+++ b/Memory/.bazeliskrc
@@ -1 +1 @@
-USE_BAZEL_VERSION=4.2.1
+USE_BAZEL_VERSION=4.2.1
diff --git a/Memory/BUILD b/Memory/BUILD
index cc43199..c485416 100644
--- a/Memory/BUILD
+++ b/Memory/BUILD
@@ -1,18 +1,86 @@
-##load("@rules_cc//cc:defs.bzl", "cc_test")  #load the test target
-
-cc_test(
-    name = "mma_test",
-    size = "small",
-    srcs = ["mma_test.cc"],
-    deps = [
-        "@gtest//:gtest_main",
-        "//lib:utils_lib",
-        "//lib:memory_manager_lib",
-        ],
-    copts = [
-        "-std=c++11",
-    ],
-    linkopts = [
-        "-pthread",
-    ]
+##load("@rules_cc//cc:defs.bzl", "cc_test")  #load the test target
+
+cc_test(
+    name = "mma_test",
+    size = "small",
+    srcs = ["mma_test.cc"],
+    deps = [
+        "@gtest//:gtest_main",
+        "//lib:utils_lib",
+        "//lib:memory_manager_lib",
+        ],
+    copts = [
+        "-std=c++11",
+    ],
+    linkopts = [
+        "-pthread",
+    ],
+)
+
+cc_test(
+    name = "q1",
+    size = "small",
+    srcs = ["q1.cc"],
+    deps = [
+        "@gtest//:gtest_main",
+        "//lib:utils_lib",
+        "//lib:memory_manager_lib",
+        ],
+    copts = [
+        "-std=c++11",
+    ],
+    linkopts = [
+        "-pthread",
+    ],
+)
+
+cc_test(
+    name = "q2",
+    size = "small",
+    srcs = ["q2.cc"],
+    deps = [
+        "@gtest//:gtest_main",
+        "//lib:utils_lib",
+        "//lib:memory_manager_lib",
+        ],
+    copts = [
+        "-std=c++11",
+    ],
+    linkopts = [
+        "-pthread",
+    ],
+)
+
+cc_test(
+    name = "q3",
+    size = "small",
+    srcs = ["q3.cc"],
+    deps = [
+        "@gtest//:gtest_main",
+        "//lib:utils_lib",
+        "//lib:memory_manager_lib",
+        ],
+    copts = [
+        "-std=c++11",
+    ],
+    linkopts = [
+        "-pthread",
+    ],
+)
+
+cc_test(
+    name = "q4",
+    size = "small",
+    srcs = ["q4.cc"],
+    deps = [
+        "@gtest//:gtest_main",
+        "//lib:utils_lib",
+        "//lib:memory_manager_lib",
+        ],
+    copts = [
+        "-std=c++11",
+    ],
+    linkopts = [
+        "-pthread",
+    ],
 )
\ No newline at end of file
diff --git a/Memory/README.md b/Memory/README.md
index 59263bb..8f684fa 100644
--- a/Memory/README.md
+++ b/Memory/README.md
@@ -1,68 +1,68 @@
-# Memory Management
-
-In this experiment, you will emulate a simple memory management system in the OS.  Your memory manager will handle memory allocation, access, and release from user applications.  It will also support page replacement policies so that applications have access to a much larger array list than the available memory.   You will need to consider thread safety as your memory manager is shared among many threads.
-
-In a nutshell, the memory manager emulation works like the following (see the next section for a detailed discussion of the sample code): 
-
-1) On initialization, the MemoryManager allocates a fixed number of PageFrames.  The number will not change throughout the entire process.  The MemoryManager will manage these pages, including tracking empty pages, and allocations, etc. 
-
-2) The MemoryManager allocates memory to applications through the creation of ArrayList objects.  All subsequent access to the memory from the MemoryManager should go through the ArrayList interfaces.  That is, you should not access the underlying memory arrays directly.  Each ArrayList has an ID assigned by the MemoryManager.  You can choose to use or not to use that ID, but you should not remove it.   
-
-3) The `mma` should support `PageIn`s and `PageOut`s once its PageFrames runs low.  To do so,  the MemoryManager can choose to track memory accesses.  For emulation, you can track all memory accesses in software, but please keep the tracking overhead as low as you can.
-
-4) The MemoryManager and all single accesses to the memory should be thread-safe. 
-
-## Codebase Introduction
-
-The test cases in `mma_test.cc` serve as documentation for the MemoryManager interface usage. 
-
-We encapsulate such a memory segment in the class of `ArrayList` (see `lib/array_list.h`).   `ArrayList` provides basic `Read` and `Write` functions for workloads to access memory. Note that `ArrayList` only registers the memory segment in the `memory_manager` (`mma` for short) with a unique identification `array_id` instead of holding the memory directly.  You can allocate ArrayLists using the `mma`.
-
-We provide interface definition of `mma` in `lib/memory_manager.h`.   See the file for places you can modify and places you cannot modify.
-
-Specifically, you should implement the following functionalities in the `mma` :
-
-- `PageFrame`: `mma` organizes its memory space as an array of pages. The page size is 4KB. In this experiment, we implement page data structure as `PageFrame`. `PageFrame`should support random access and serialization/deserialization (i.e., save the content of pages in disks using `WriteDisk()` method and recover a page from disk files using `ReadDisk()` method) 
-
-- `PageInfo`: `mma` records necessary information for each page (e.g., the current virtual page it holds on). You can put additional states of each page in this structure for other functionalities if you see necessary. 
-
-- `ReadPage/WritePage`: when applications read/write a new value to the ArrayList (using the ArrayList interface), the value should eventually find its correct memory location in the pre-allocated memory in MemoryManager.   It is your call whether to do the address translation in the ArrayList object or in the `mma`.   Note that ArrayList accesses 4 bytes of memory at a time in this experiment. 
-
-- `PageReplacement`: when the number of page frames allocated in ArrayLists exceeds the available number of page frames in the `mma`, `mma` should page out some pages to disk files.  Implement your `mma`'s page replacement algorithms with `PageOut` method to store a page into a file and `PageIn` method to load a page from the file.  You should use a reasonable algorithm to minimize the number of page-ins and outs. For simplicity, you can use `array_id` and `virtual_page_id` to identify disk files of each page.
-
-- `Allocate/Release`: when `mma` allocates an `ArrayList`, it should assign a unique ID to the ArrayList, and allocate PageFrames to the ArrayList.  Note that you are no need to allocate physical pages to some `ArrayList` as soon as it is created.   When as soon as an  `ArrayList`  is destroyed, `mma` should reclaim the PageFrames (both in memory and on disk), synchronously. Note that a PageFrame is the smallest allocation unit in this experiment, so allocating slightly larger memory than required to applications is acceptable.
-
-- If your replacement policy requires, you can track the memory accesses (read or write or both) in the `mma`.  
-
-`mma_test.cc` provides basic tests for memory manager validation and observation experiments, the first three tasks for single-thread scenarios, and the fourth task for multi-thread scenarios.
-
-You can utilize basic tools in `utils.h` to write tests for your `mma` functions.
-
-## TODO
-
-## Q1
-
-Implement your `mma` and `ArrayList` to support single-thread scenarios. The page replacement algorithm should be FIFO. Observe and record the time it costs to pass the first three tests. 
-
-## Q2
-
-Implement a clock algorithm (approximate LRU) for page replacement instead of your FIFO in Q1.  Observe and record the time it costs to pass the three tests. Compare two parts of experiment results, analyze the difference. 
-
-## Q3
-
-Vary the `mma` memory allocation from 1 to 10 (1,2,...,10) and re-run test 2 for both algorithms.  Observe and record the time it costs to pass the tests. Analyze the reason for the result variation and the differences between the two algorithms.
-
-## Q4
-
-Implement your `mma` to support multi-thread scenarios while guaranteeing thread safety.  The page replacement algorithm should be the clock algorithm. Vary the thread number from  10 to 20 to pass the 4th test. What can you observe? Try to analyze the results. 
-
-## Grading
-
-We will use extra workloads to test your `mma`, so your implementation should not rely on `mma_test.cc`. We grade with the following three requirements:
-
-1. Correctness: pass all tests in  `mma_test.cc` and extra tests;
-2. Performance: we will consider the time it takes to pass the tests. For concurrent tests, it should
-    be significantly faster than running all tasks sequentially - so you should not let `mma` process requests one by one. 
-3. Observation and analysis: submit a PDF to display your experiment results in Q1 - Q4 and try to explain the rationales behind the results. Pack your PDF and diff files as a zip for submission.
-
-Submit the diff file that can be correctly applied to `ec3155c3`.
+# Memory Management
+
+In this experiment, you will emulate a simple memory management system in the OS.  Your memory manager will handle memory allocation, access, and release from user applications.  It will also support page replacement policies so that applications have access to a much larger array list than the available memory.   You will need to consider thread safety as your memory manager is shared among many threads.
+
+In a nutshell, the memory manager emulation works like the following (see the next section for a detailed discussion of the sample code): 
+
+1) On initialization, the MemoryManager allocates a fixed number of PageFrames.  The number will not change throughout the entire process.  The MemoryManager will manage these pages, including tracking empty pages, and allocations, etc. 
+
+2) The MemoryManager allocates memory to applications through the creation of ArrayList objects.  All subsequent access to the memory from the MemoryManager should go through the ArrayList interfaces.  That is, you should not access the underlying memory arrays directly.  Each ArrayList has an ID assigned by the MemoryManager.  You can choose to use or not to use that ID, but you should not remove it.   
+
+3) The `mma` should support `PageIn`s and `PageOut`s once its PageFrames runs low.  To do so,  the MemoryManager can choose to track memory accesses.  For emulation, you can track all memory accesses in software, but please keep the tracking overhead as low as you can.
+
+4) The MemoryManager and all single accesses to the memory should be thread-safe. 
+
+## Codebase Introduction
+
+The test cases in `mma_test.cc` serve as documentation for the MemoryManager interface usage. 
+
+We encapsulate such a memory segment in the class of `ArrayList` (see `lib/array_list.h`).   `ArrayList` provides basic `Read` and `Write` functions for workloads to access memory. Note that `ArrayList` only registers the memory segment in the `memory_manager` (`mma` for short) with a unique identification `array_id` instead of holding the memory directly.  You can allocate ArrayLists using the `mma`.
+
+We provide interface definition of `mma` in `lib/memory_manager.h`.   See the file for places you can modify and places you cannot modify.
+
+Specifically, you should implement the following functionalities in the `mma` :
+
+- `PageFrame`: `mma` organizes its memory space as an array of pages. The page size is 4KB. In this experiment, we implement page data structure as `PageFrame`. `PageFrame`should support random access and serialization/deserialization (i.e., save the content of pages in disks using `WriteDisk()` method and recover a page from disk files using `ReadDisk()` method) 
+
+- `PageInfo`: `mma` records necessary information for each page (e.g., the current virtual page it holds on). You can put additional states of each page in this structure for other functionalities if you see necessary. 
+
+- `ReadPage/WritePage`: when applications read/write a new value to the ArrayList (using the ArrayList interface), the value should eventually find its correct memory location in the pre-allocated memory in MemoryManager.   It is your call whether to do the address translation in the ArrayList object or in the `mma`.   Note that ArrayList accesses 4 bytes of memory at a time in this experiment. 
+
+- `PageReplacement`: when the number of page frames allocated in ArrayLists exceeds the available number of page frames in the `mma`, `mma` should page out some pages to disk files.  Implement your `mma`'s page replacement algorithms with `PageOut` method to store a page into a file and `PageIn` method to load a page from the file.  You should use a reasonable algorithm to minimize the number of page-ins and outs. For simplicity, you can use `array_id` and `virtual_page_id` to identify disk files of each page.
+
+- `Allocate/Release`: when `mma` allocates an `ArrayList`, it should assign a unique ID to the ArrayList, and allocate PageFrames to the ArrayList.  Note that you are no need to allocate physical pages to some `ArrayList` as soon as it is created.   When as soon as an  `ArrayList`  is destroyed, `mma` should reclaim the PageFrames (both in memory and on disk), synchronously. Note that a PageFrame is the smallest allocation unit in this experiment, so allocating slightly larger memory than required to applications is acceptable.
+
+- If your replacement policy requires, you can track the memory accesses (read or write or both) in the `mma`.  
+
+`mma_test.cc` provides basic tests for memory manager validation and observation experiments, the first three tasks for single-thread scenarios, and the fourth task for multi-thread scenarios.
+
+You can utilize basic tools in `utils.h` to write tests for your `mma` functions.
+
+## TODO
+
+## Q1
+
+Implement your `mma` and `ArrayList` to support single-thread scenarios. The page replacement algorithm should be FIFO. Observe and record the time it costs to pass the first three tests. 
+
+## Q2
+
+Implement a clock algorithm (approximate LRU) for page replacement instead of your FIFO in Q1.  Observe and record the time it costs to pass the three tests. Compare two parts of experiment results, analyze the difference. 
+
+## Q3
+
+Vary the `mma` memory allocation from 1 to 10 (1,2,...,10) and re-run test 2 for both algorithms.  Observe and record the time it costs to pass the tests. Analyze the reason for the result variation and the differences between the two algorithms.
+
+## Q4
+
+Implement your `mma` to support multi-thread scenarios while guaranteeing thread safety.  The page replacement algorithm should be the clock algorithm. Vary the thread number from  10 to 20 to pass the 4th test. What can you observe? Try to analyze the results. 
+
+## Grading
+
+We will use extra workloads to test your `mma`, so your implementation should not rely on `mma_test.cc`. We grade with the following three requirements:
+
+1. Correctness: pass all tests in  `mma_test.cc` and extra tests;
+2. Performance: we will consider the time it takes to pass the tests. For concurrent tests, it should
+    be significantly faster than running all tasks sequentially - so you should not let `mma` process requests one by one. 
+3. Observation and analysis: submit a PDF to display your experiment results in Q1 - Q4 and try to explain the rationales behind the results. Pack your PDF and diff files as a zip for submission.
+
+Submit the diff file that can be correctly applied to `ec3155c3`.
diff --git a/Memory/WORKSPACE b/Memory/WORKSPACE
index 6760453..6d24ab2 100644
--- a/Memory/WORKSPACE
+++ b/Memory/WORKSPACE
@@ -1,15 +1,15 @@
-load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
-
-## google test dependency
-http_archive(
-  name = "gtest",
-  urls = ["https://github.com.cnpmjs.org/google/googletest/archive/refs/tags/release-1.11.0.zip"],
-  strip_prefix = "googletest-release-1.11.0",
-)
-## google benchmark dependency
-http_archive(
-  name = "gbench",
-  urls = ["https://github.com.cnpmjs.org/google/benchmark/archive/refs/tags/v1.6.0.zip"],
-  strip_prefix = "benchmark-1.6.0",
-  sha256 = "3da225763533aa179af8438e994842be5ca72e4a7fed4d7976dc66c8c4502f58"
-)
+load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
+
+## google test dependency
+http_archive(
+  name = "gtest",
+  urls = ["https://github.com.cnpmjs.org/google/googletest/archive/refs/tags/release-1.11.0.zip"],
+  strip_prefix = "googletest-release-1.11.0",
+)
+## google benchmark dependency
+http_archive(
+  name = "gbench",
+  urls = ["https://github.com.cnpmjs.org/google/benchmark/archive/refs/tags/v1.6.0.zip"],
+  strip_prefix = "benchmark-1.6.0",
+  sha256 = "3da225763533aa179af8438e994842be5ca72e4a7fed4d7976dc66c8c4502f58"
+)
diff --git a/Memory/lib/BUILD b/Memory/lib/BUILD
index b145dc0..620da17 100644
--- a/Memory/lib/BUILD
+++ b/Memory/lib/BUILD
@@ -1,31 +1,53 @@
-##load("@rules_cc//cc:defs.bzl", "cc_test")  #load the test target
-
-cc_library(
-    name = "utils_lib",
-    srcs = [
-        "utils.cc",
-        ],
-    hdrs = [
-        "utils.h",
-        ],
-	visibility = [
-		"//visibility:public",
-	],
-)
-
-cc_library(
-    name = "memory_manager_lib",
-    srcs = [
-        "memory_manager.cc",
-        "array_list.cc",
-        ],
-    hdrs = [
-        "memory_manager.h",
-        "array_list.h",
-        ],
-	visibility = [
-		"//visibility:public",
-	],
-)
-
-
+##load("@rules_cc//cc:defs.bzl", "cc_test")  #load the test target
+
+cc_library(
+    name = "utils_lib",
+    srcs = [
+        "utils.cc",
+        ],
+    hdrs = [
+        "utils.h",
+        ],
+	visibility = [
+		"//visibility:public",
+	],
+)
+
+cc_library(
+    name = "memory_manager_lib",
+    srcs = [
+        "memory_manager.cc",
+        "array_list.cc",
+        ],
+    hdrs = [
+        "memory_manager.h",
+        "array_list.h",
+        ],
+    deps = [
+        "semaphore",
+    ],
+	visibility = [
+		"//visibility:public",
+	],
+)
+
+cc_library(
+    name = "semaphore",
+    srcs = [
+        "semaphore.cc",
+        ],
+    hdrs = [
+        "semaphore.h",
+        ],
+	visibility = [
+		"//visibility:public",
+	],
+    copts = [
+        "-O3",
+        "-std=c++11",
+    ],
+	linkopts = [
+        "-pthread",
+    ],
+)
+
diff --git a/Memory/lib/array_list.cc b/Memory/lib/array_list.cc
index a9abedb..97e6f36 100644
--- a/Memory/lib/array_list.cc
+++ b/Memory/lib/array_list.cc
@@ -1,16 +1,23 @@
-#include "array_list.h"
-
-#include "memory_manager.h"
-
-namespace proj3 {
-    ArrayList::ArrayList(size_t sz, MemoryManager* cur_mma, int id){
-    }
-    int ArrayList::Read (unsigned long idx){
-        //read the value in the virtual index of 'idx' from mma's memory space
-    }
-    void ArrayList::Write (unsigned long idx, int value){
-        //write 'value' in the virtual index of 'idx' into mma's memory space
-    }
-    ArrayList::~ArrayList(){
-    }
-} // namespce: proj3
\ No newline at end of file
+#include "array_list.h"
+
+#include "memory_manager.h"
+
+namespace proj3 {
+    ArrayList::ArrayList(size_t sz, MemoryManager* cur_mma, int id){
+        this -> mma = cur_mma;
+        this -> array_id = id;
+        this -> size = sz;
+
+    }
+    int ArrayList::Read (unsigned long idx){
+        //read the value in the virtual index of 'idx' from mma's memory space
+        return mma -> ReadPage(this -> array_id, idx / PageSize, idx % PageSize);
+    }
+    void ArrayList::Write (unsigned long idx, int value){
+        //write 'value' in the virtual index of 'idx' into mma's memory space
+        mma -> WritePage(this -> array_id, idx/PageSize, idx % PageSize, value);
+    }
+    ArrayList::~ArrayList(){
+        mma -> Release(this);
+    }
+} // namespace: proj3
\ No newline at end of file
diff --git a/Memory/lib/array_list.h b/Memory/lib/array_list.h
index dd46ab1..d48394b 100644
--- a/Memory/lib/array_list.h
+++ b/Memory/lib/array_list.h
@@ -1,25 +1,25 @@
-#ifndef ARRAY_LIST_H
-#define ARRAY_LIST_H
-
-#include <cstdlib>
-
-namespace proj3 {
-
-    class MemoryManager;
-
-    class ArrayList{
-        private:
-        friend class MemoryManager;
-        size_t size;
-        MemoryManager* mma;
-        int array_id;
-        ArrayList(size_t, MemoryManager*, int);
-        ~ArrayList();
-        public:
-        // you should not modify the public interfaces used in tests
-        int Read (unsigned long);
-        void Write (unsigned long, int);
-    };
-
-} // namespce: proj3
+#ifndef ARRAY_LIST_H
+#define ARRAY_LIST_H
+
+#include <cstdlib>
+
+namespace proj3 {
+
+    class MemoryManager;
+
+    class ArrayList{
+        private:
+        friend class MemoryManager;
+        size_t size;
+        MemoryManager* mma;
+        int array_id;
+        ArrayList(size_t, MemoryManager*, int);
+        ~ArrayList();
+        public:
+        // you should not modify the public interfaces used in tests
+        int Read (unsigned long);
+        void Write (unsigned long, int);
+    };
+
+} // namespce: proj3
 #endif
\ No newline at end of file
diff --git a/Memory/lib/memory_manager.cc b/Memory/lib/memory_manager.cc
index 9b29245..d01c188 100644
--- a/Memory/lib/memory_manager.cc
+++ b/Memory/lib/memory_manager.cc
@@ -1,61 +1,384 @@
-#include "memory_manager.h"
+#include <chrono>
+#include <thread>
+
+
+#include <string.h>
 
+#include "memory_manager.h"
 #include "array_list.h"
 
 namespace proj3 {
     PageFrame::PageFrame(){
     }
+
     int& PageFrame::operator[] (unsigned long idx){
         //each page should provide random access like an array
+        return mem[idx];
     }
-    void PageFrame::WriteDisk(std::string filename) {
-        // write page content into disk files
+
+    void PageFrame::WriteDisk(std::string filename) {    
+        FILE* f = fopen(filename.c_str(), "wb");
+        if(f == nullptr){
+            throw std::runtime_error("error openning file "+filename+"!");
+        } else {
+            fwrite(mem, sizeof(int), PageSize, f);
+            fclose(f);
+        }
     }
+
     void PageFrame::ReadDisk(std::string filename) {
-        // read page content from disk files
+        FILE* f = fopen(filename.c_str(),"rb");
+        if (f == nullptr) {
+            memset(mem,0,sizeof(int)*PageSize);
+            f = fopen(filename.c_str(),"wb");
+            fwrite(mem, sizeof(int), PageSize, f);
+            fclose(f);
+        } else {
+            fread(mem, sizeof(int), PageSize, f);
+            fclose(f);
+        }        
     }
-
+    
     PageInfo::PageInfo(){
+        holder = -1;
+        virtual_page_id = -1;
     }
+
     void PageInfo::SetInfo(int cur_holder, int cur_vid){
         //modify the page states
         //you can add extra parameters if needed
+        holder = cur_holder;
+        virtual_page_id = cur_vid;
     }
+
     void PageInfo::ClearInfo(){
         //clear the page states
         //you can add extra parameters if needed
+        holder = -1;
+        virtual_page_id = -1;
     }
 
-    int PageInfo::GetHolder(){}
-    int PageInfo::GetVid(){}
-    
+    int PageInfo::GetHolder(){return holder;}
+    int PageInfo::GetVid(){return virtual_page_id;}
 
-    MemoryManager::MemoryManager(size_t sz){
-        //mma should build its memory space with given space size
-        //you should not allocate larger space than 'sz' (the number of physical pages) 
+    MemoryManager::MemoryManager(size_t sz, ReplacementPolicy Policy, bool Test_mode){
+        mma_sz = sz;
+        mem = new PageFrame[sz];
+        page_info = new PageInfo[sz];
+        free = new bool[sz];
+        used = new bool[sz];
+        modified = new bool[sz];
+        for (int i = 0 ; i < int(sz); i ++){
+            free[i] = true;
+            used[i] = false;
+            modified[i] = false;
+        }
+        policy = Policy;
+        test_mode = Test_mode;
     }
-    MemoryManager::~MemoryManager(){
+
+    MemoryManager::~MemoryManager(){  
+        for (auto it = filename_exist.cbegin(); it != filename_exist.cend(); ++it) {
+            if ((*it).second)
+                remove(((*it).first).c_str());
+        }
+        delete free;
+        delete used;
+        delete modified;
+        delete mem;
+        delete page_info;
     }
-    void MemoryManager::PageOut(int physical_page_id){
-        //swap out the physical page with the indx of 'physical_page_id out' into a disk file
+
+    void MemoryManager::PageOut(int physical_page_id, std::string filename) {
+        mem[physical_page_id].WriteDisk(filename);
+        filename_exist[filename] = true;
+        if (test_mode)
+            std::this_thread::sleep_for(std::chrono::milliseconds(100));
     }
+
     void MemoryManager::PageIn(int array_id, int virtual_page_id, int physical_page_id){
-        //swap the target page from the disk file into a physical page with the index of 'physical_page_id out'
+        std::string name = file_name(array_id, virtual_page_id);
+        mem[physical_page_id].ReadDisk(name);
+        filename_exist[name] = true;
+        if (test_mode)
+            std::this_thread::sleep_for(std::chrono::milliseconds(100));
     }
-    void MemoryManager::PageReplace(int array_id, int virtual_page_id){
+
+    int MemoryManager::PageReplace(int array_id, int virtual_page_id, bool is_write,  std::string& output_filename){
         //implement your page replacement policy here
+        //try to find a free page
+        int i;
+        for ( i = 0 ; i < int(mma_sz) ; i ++ ) {
+            if (free[i]) break;
+        }
+        if ( i < int(mma_sz)) {
+            //A free page found
+            page_map[array_id][virtual_page_id] = i;
+            free[i] = false;
+            used[i] = true;
+            modified[i] = is_write;
+            page_info[i].SetInfo(array_id, virtual_page_id);
+            //////////////////////////////////
+            int times_to_wait = 0;
+            resource_queue[page_name(i)].push(array_id);
+            if (resource_queue[page_name(i)].size() > 1) {
+                times_to_wait ++;
+            }
+            resource_queue[file_name(array_id, virtual_page_id)].push(array_id);
+            if (resource_queue[file_name(array_id, virtual_page_id)].size() > 1){
+                times_to_wait ++;
+            }
+            data_lock.unlock();
+            for (int j = 0; j < times_to_wait; j ++) {
+                sp[array_id].P();
+            }
+            //////////////////////////////////
+            PageIn(array_id, virtual_page_id, i);
+            return i;
+        } else {
+            if (policy == CLOCK) {
+                //clock algorithm
+                while(true) {
+                    if (used[clock_head]) {
+                        used[clock_head] = false;
+                        clock_head = (clock_head + 1) % int (mma_sz);
+                    } else {
+                        break;
+                    }
+                }
+            }
+            int pid = clock_head;
+            clock_head = (clock_head + 1) % int(mma_sz);
+            //update page_map
+            int old_holder = page_info[pid].GetHolder();
+            int old_vid = page_info[pid].GetVid();
+            //page_map[old_holder][old_vid] = -1;//Page table cleared
+            bool dirty = modified[pid];
+            page_info[pid].SetInfo(array_id, virtual_page_id);
+            page_map[array_id][virtual_page_id] = pid;
+            page_map[old_holder][old_vid] = -1;
+            free[pid] = false;
+            used[pid] = true;
+            modified[pid] = is_write;
+            if(dirty)output_filename = file_name(old_holder, old_vid);
+            //////////////////////////////////
+            int times_to_wait = 0;
+            resource_queue[page_name(pid)].push(array_id);
+            if (resource_queue[page_name(pid)].size() > 1){
+                times_to_wait ++;
+            }
+            resource_queue[file_name(array_id, virtual_page_id)].push(array_id);
+            if (resource_queue[file_name(array_id, virtual_page_id)].size() > 1){
+                times_to_wait ++;
+            }
+            if (dirty) {
+                resource_queue[output_filename].push(array_id);
+                if (resource_queue[output_filename].size() > 1) {
+                    times_to_wait ++;
+                }
+            }
+            data_lock.unlock();
+            for (int j = 0; j < times_to_wait; j ++) {
+                sp[array_id].P();
+            }
+            //////////////////////////////////
+            if(dirty)PageOut(pid, output_filename);
+            PageIn(array_id, virtual_page_id, pid);
+            return pid;
+        }
+
     }
+
     int MemoryManager::ReadPage(int array_id, int virtual_page_id, int offset){
         // for arrayList of 'array_id', return the target value on its virtual space
+        //////////////////////////////////
+        data_lock.lock();
+        //////////////////////////////////
+        bool in_memory = true;
+        if (page_map.count(array_id) == 0) {
+            //the arraylist is first used
+            page_map[array_id] = std::map<int, int>();
+            in_memory = false;
+        } else if (page_map[array_id].count(virtual_page_id) == 0){
+            in_memory = false;
+            //virtual page is first used
+            if (int(page_map[array_id].size()) == num_max_pages[array_id]) {
+                data_lock.unlock();
+                throw std::runtime_error("Array List " + std::to_string(array_id)+" exceeds the allocated space!");
+            }
+        } else if (page_map[array_id][virtual_page_id] == -1) {
+            in_memory = false;
+        }
+        if (in_memory) {
+            int pid = page_map[array_id][virtual_page_id];
+            used[pid] = true;
+            //////////////////////////////////
+            resource_queue[page_name(pid)].push(array_id);
+            int queue_size = resource_queue[page_name(pid)].size();
+            data_lock.unlock();
+            if (queue_size > 1) {
+                sp[array_id].P();
+            }
+            //////////////////////////////////
+            int result = (mem[pid])[offset];
+            //////////////////////////////////
+            data_lock.lock();
+            resource_queue[page_name(pid)].pop();
+            if (resource_queue[page_name(pid)].size() > 0) {
+                sp[resource_queue[page_name(pid)].front()].V();
+            }
+            data_lock.unlock();
+            //////////////////////////////////
+            return result; 
+        } else {
+            std::string input_filename = file_name(array_id, virtual_page_id);
+            std::string output_filename;
+
+            int pid = PageReplace(array_id, virtual_page_id, false, output_filename);
+            
+            int result = (mem[pid])[offset];
+            //////////////////////////////////
+            data_lock.lock();
+            resource_queue[page_name(pid)].pop();
+            if (resource_queue[page_name(pid)].size() > 0) {
+                sp[resource_queue[page_name(pid)].front()].V();
+            }
+            resource_queue[input_filename].pop();
+            if (resource_queue[input_filename].size() > 0) {
+                sp[resource_queue[input_filename].front()].V();
+            }
+
+            if (output_filename.size() > 0) {
+                resource_queue[output_filename].pop();
+                if (resource_queue[output_filename].size() > 0) {
+                    sp[resource_queue[output_filename].front()].V();
+                }
+            }
+            data_lock.unlock();
+            //////////////////////////////////
+            return result; 
+        }
     }
+
     void MemoryManager::WritePage(int array_id, int virtual_page_id, int offset, int value){
         // for arrayList of 'array_id', write 'value' into the target position on its virtual space
+        //////////////////////////////////
+        data_lock.lock();
+        //////////////////////////////////
+        
+        bool in_memory = true;
+        if (page_map.count(array_id) == 0) {
+            //the arraylist is first used
+            page_map[array_id] = std::map<int, int>();
+            in_memory = false;
+        } else if (page_map[array_id].count(virtual_page_id) == 0){
+            //virtual page is first used
+            in_memory = false;
+            if (int(page_map[array_id].size()) == num_max_pages[array_id]) {
+                data_lock.unlock();
+                throw std::runtime_error("Array List " + std::to_string(array_id)+" exceeds the allocated space!");
+            } 
+        } else if (page_map[array_id][virtual_page_id] == -1) {
+            in_memory = false;
+        }
+        
+        if (in_memory) {
+            int pid = page_map[array_id][virtual_page_id];
+            used[pid] = true;
+            modified[pid] = true;
+            
+            //////////////////////////////////
+            resource_queue[page_name(pid)].push(array_id);
+            int queue_size = resource_queue[page_name(pid)].size();
+            data_lock.unlock();
+            if (queue_size > 1) {
+                sp[array_id].P();
+            }
+            //////////////////////////////////
+
+            (mem[pid])[offset] = value;
+
+            //////////////////////////////////
+            data_lock.lock();
+            resource_queue[page_name(pid)].pop();
+            if (resource_queue[page_name(pid)].size() > 0) {
+                sp[resource_queue[page_name(pid)].front()].V();
+            }
+            data_lock.unlock();
+            //////////////////////////////////
+            
+            return; 
+        } else {
+            std::string input_filename = file_name(array_id, virtual_page_id);
+            std::string output_filename ;
+            int pid = PageReplace(array_id, virtual_page_id, true, output_filename);//datalock -> pagelock
+            (mem[pid])[offset] = value;
+            //////////////////////////////////
+            data_lock.lock();
+            resource_queue[page_name(pid)].pop();
+            if (resource_queue[page_name(pid)].size() > 0) {
+                sp[resource_queue[page_name(pid)].front()].V();
+            }
+            resource_queue[input_filename].pop();
+            if (resource_queue[input_filename].size() > 0) {
+                sp[resource_queue[input_filename].front()].V();
+            }
+
+            if (output_filename.size() > 0) {
+                resource_queue[output_filename].pop();
+                if (resource_queue[output_filename].size() > 0) {
+                    sp[resource_queue[output_filename].front()].V();
+                }
+            }
+            data_lock.unlock();
+            //////////////////////////////////
+            return;
+        }
     }
+
     ArrayList* MemoryManager::Allocate(size_t sz){
-        // when an application requires for memory, create an ArrayList and record mappings from its virtual memory space to the physical memory space
+        // when an application requires for memory, 
+        //create an ArrayList and record mappings
+        //from its virtual memory space to the physical memory space
+        data_lock.lock();
+
+        num_max_pages[next_array_id] = (int(sz) + int(PageSize) - 1)/int(PageSize);
+        next_array_id ++;
+        ArrayList* list = new ArrayList(sz, this, next_array_id - 1);
+
+        data_lock.unlock();
+        return list;
+
     }
     void MemoryManager::Release(ArrayList* arr){
         // an application will call release() function when destroying its arrayList
         // release the virtual space of the arrayList and erase the corresponding mappings
+
+        int array_id = arr -> array_id;
+        data_lock.lock();
+        std::map<int, int>::iterator it = page_map[array_id].begin();
+        for (; it != page_map[array_id].end(); ++ it) {
+            int vid = it -> first;
+            int pid = it -> second;
+            std::string name = file_name(array_id, vid);
+            remove(name.c_str());
+            filename_exist[name] = false;
+            if (pid != -1) {
+                free[pid] = true;
+                used[pid] = false;
+                modified[pid] = false;
+                page_info[pid].ClearInfo();
+            }
+        }
+        data_lock.unlock();
+    }
+
+    std::string file_name(int holder, int vid) {
+        return "f" + std::to_string(holder) +'_'+std::to_string(vid);
+    }
+
+    std::string page_name(int pid) {
+        return "p" + std::to_string(pid);
     }
-} // namespce: proj3
\ No newline at end of file
+
+} // namespace: proj3
diff --git a/Memory/lib/memory_manager.h b/Memory/lib/memory_manager.h
index 59fcd35..7853ca5 100644
--- a/Memory/lib/memory_manager.h
+++ b/Memory/lib/memory_manager.h
@@ -1,66 +1,92 @@
-#ifndef MEMORY_MANAGER_H_
-#define MEMORY_MANAGER_H_
-
-#include <assert.h>
-#include <map>
-#include <string>
-#include <cstdlib>
-#include<cstdio>
-
-#define PageSize 1024
-
-namespace proj3 {
-
-class PageFrame {
-public:
-    PageFrame();
-    int& operator[] (unsigned long);
-    void WriteDisk(std::string);
-    void ReadDisk(std::string);
-private:
-    int mem[PageSize];
-};
-
-class PageInfo {
-public:
-    PageInfo();
-    void SetInfo(int,int);
-    void ClearInfo();
-    int GetHolder();
-    int GetVid();
-private:
-    int holder; //page holder id (array_id)
-    int virtual_page_id; // page virtual #
-    /*add your extra states here freely for implementation*/
-
-};
-
-class ArrayList;
-
-class MemoryManager {
-public:
-    // you should not modify the public interfaces used in tests
-    MemoryManager(size_t);
-    int ReadPage(int array_id, int virtual_page_id, int offset);
-    void WritePage(int array_id, int virtual_page_id, int offset, int value);
-    ArrayList* Allocate(size_t);
-    void Release(ArrayList*);
-    ~MemoryManager();
-private:
-    std::map<int, std::map<int, int>> page_map; // // mapping from ArrayList's virtual page # to physical page #
-    PageFrame** mem; // physical pages, using 'PageFrame* mem' is also acceptable 
-    PageInfo* page_info; // physical page info
-    unsigned int* free_list;  // use bitmap implementation to identify and search for free pages
-    int next_array_id;
-    size_t mma_sz;
-    /*add your extra states here freely for implementation*/
-
-    void PageIn(int array_id, int virtual_page_id, int physical_page_id);
-    void PageOut(int physical_page_id);
-    void PageReplace(int array_id, int virtual_page_id);
-};
-
-}  // namespce: proj3
-
-#endif
-
+#ifndef MEMORY_MANAGER_H_
+#define MEMORY_MANAGER_H_
+#include <map>
+#include <queue>
+#include <string>
+#include <vector>
+#include "semaphore.h"
+
+#define PageSize 1024
+
+namespace proj3 {
+
+class PageFrame {
+public:
+    PageFrame();
+    int& operator[] (unsigned long);
+    void WriteDisk(std::string);
+    void ReadDisk(std::string);
+private:
+    int mem[PageSize];
+};
+
+class PageInfo {
+public:
+    PageInfo();
+    void SetInfo(int,int);
+    void ClearInfo();
+    int GetHolder();
+    int GetVid();
+private:
+    int holder; //page holder id (array_id)
+    int virtual_page_id; // page virtual #
+    /*add your extra states here freely for implementation*/
+};
+
+class ArrayList;
+
+enum ReplacementPolicy{
+    FIFO = 0,
+    CLOCK
+};
+
+class MemoryManager {
+public:
+    // you should not modify the public interfaces used in tests
+    MemoryManager(size_t, ReplacementPolicy Policy = FIFO, bool Test_mode = false);
+    int ReadPage(int array_id, int virtual_page_id, int offset);
+    void WritePage(int array_id, int virtual_page_id, int offset, int value);
+    ArrayList* Allocate(size_t);
+    void Release(ArrayList*);
+    ~MemoryManager();
+
+    
+private:
+    std::map<std::string, int*> disk;
+    std::map<int, std::map<int, int>> page_map;
+    // mapping from ArrayList's virtual page # to physical page #
+    PageFrame* mem; // physical pages, using 'PageFrame* mem' is also acceptable 
+    PageInfo* page_info; // physical page info
+    int next_array_id = 0;
+    size_t mma_sz;
+    void PageIn(int array_id, int virtual_page_id, int physical_page_id);
+    void PageOut(int physical_page_id, std::string filename);
+    int PageReplace(int array_id, int virtual_page_id, bool is_write, std::string& output_filename);
+
+    //states of the memory
+    bool* free;
+    bool* used;
+    bool* modified;
+
+    bool test_mode = false;
+    ReplacementPolicy policy;
+    int clock_head = 0;
+    //states of the array_list
+    std::map<int, int> num_max_pages;
+    //array_id -> number of available pages
+    //extra functions
+    std::map<std::string, bool> filename_exist;
+
+    //Manage the queues
+    std::map<std::string, std::queue<int>> resource_queue;
+    std::map<int, Semaphore> sp;
+    std::mutex data_lock;//guards the metadata
+};
+
+std::string file_name(int,int);
+std::string page_name(int);
+
+}  // namespce: proj3
+
+#endif
+
diff --git a/Memory/lib/semaphore.cc b/Memory/lib/semaphore.cc
new file mode 100644
index 0000000..0f8ad15
--- /dev/null
+++ b/Memory/lib/semaphore.cc
@@ -0,0 +1,18 @@
+#include "semaphore.h"
+
+namespace proj3 {
+    void Semaphore::P() {
+        std::unique_lock<std::mutex> loc(m);
+        if (--count < 0) {
+            cv.wait(loc);
+        }
+    }
+
+    void Semaphore::V() {
+        std::unique_lock<std::mutex> loc(m);
+        if (++count <= 0) {
+            cv.notify_one();
+        }
+    }
+
+}//proj3
\ No newline at end of file
diff --git a/Memory/lib/semaphore.h b/Memory/lib/semaphore.h
new file mode 100644
index 0000000..f9ef74a
--- /dev/null
+++ b/Memory/lib/semaphore.h
@@ -0,0 +1,19 @@
+#ifndef SEMAPHORE_H_
+#define SEMAPHORE_H_
+#include <condition_variable>
+#include <mutex>
+
+namespace proj3{
+class Semaphore{
+private:
+    int count;
+    std::mutex m;
+    std::condition_variable cv;
+public:
+    Semaphore(int init = 0):count(init){}
+    void P();
+    void V();	
+};
+}//proj3
+
+#endif // SEMAPHORE_H_
diff --git a/Memory/lib/utils.cc b/Memory/lib/utils.cc
index 58e3166..2ab9ca8 100644
--- a/Memory/lib/utils.cc
+++ b/Memory/lib/utils.cc
@@ -1,24 +1,24 @@
-#include <chrono>
-#include <thread>
-#include <cstdlib>
-#include <iostream>
-#include "utils.h"
-
-namespace proj3 {
-
-void a_slow_function(int seconds) {
-    std::this_thread::sleep_for(std::chrono::seconds(seconds));
-}
-
-AutoTimer::AutoTimer(std::string name): 
-        m_name(std::move(name)),
-        m_beg(std::chrono::high_resolution_clock::now()) { 
-    }
-
-AutoTimer::~AutoTimer() {
-    auto end = std::chrono::high_resolution_clock::now();
-    auto dur = std::chrono::duration_cast<std::chrono::microseconds>(end - m_beg);
-    std::cout << m_name << " : " << dur.count() << " usec\n";
-}
-
-} // namespce: proj3
+#include <chrono>
+#include <thread>
+#include <cstdlib>
+#include <iostream>
+#include "utils.h"
+
+namespace proj3 {
+
+void a_slow_function(int seconds) {
+    std::this_thread::sleep_for(std::chrono::seconds(seconds));
+}
+
+AutoTimer::AutoTimer(std::string name): 
+        m_name(std::move(name)),
+        m_beg(std::chrono::high_resolution_clock::now()) { 
+    }
+
+AutoTimer::~AutoTimer() {
+    auto end = std::chrono::high_resolution_clock::now();
+    auto dur = std::chrono::duration_cast<std::chrono::microseconds>(end - m_beg);
+    std::cout << m_name << " : " << dur.count() << " usec\n";
+}
+
+} // namespce: proj3
diff --git a/Memory/lib/utils.h b/Memory/lib/utils.h
index fa4dac9..8c8af93 100644
--- a/Memory/lib/utils.h
+++ b/Memory/lib/utils.h
@@ -1,21 +1,21 @@
-#ifndef DEADLOCK_LIB_UTILS_H_
-#define DEADLOCK_LIB_UTILS_H_
-
-#include <chrono>
-
-namespace proj3 {
-
-void a_slow_function(int seconds);
-
-class AutoTimer {
- public:
-  AutoTimer(std::string name);
-  ~AutoTimer(); 
- private:
-  std::string m_name;
-  std::chrono::time_point<std::chrono::high_resolution_clock> m_beg;
-};
-
-}  // namespce: proj3
-
+#ifndef DEADLOCK_LIB_UTILS_H_
+#define DEADLOCK_LIB_UTILS_H_
+
+#include <chrono>
+
+namespace proj3 {
+
+void a_slow_function(int seconds);
+
+class AutoTimer {
+ public:
+  AutoTimer(std::string name);
+  ~AutoTimer(); 
+ private:
+  std::string m_name;
+  std::chrono::time_point<std::chrono::high_resolution_clock> m_beg;
+};
+
+}  // namespce: proj3
+
 #endif
\ No newline at end of file
diff --git a/Memory/mma_test.cc b/Memory/mma_test.cc
index 7b47db0..20e5ffa 100644
--- a/Memory/mma_test.cc
+++ b/Memory/mma_test.cc
@@ -1,129 +1,129 @@
-#include <gtest/gtest.h>
-#include<vector>
-#include<thread>
-
-#include "lib/array_list.h"
-#include "lib/memory_manager.h"
-
-namespace proj3 {
-namespace testing{
-
-class MMATest : public ::testing::Test {
- protected:
-  void SetUp() override {
-    mma = new proj3::MemoryManager(10);
-    workload_sz_1 = 4000; 
-    workload_sz_2 = 2000; 
-    workload_sz_3 = 100; 
-    workload_sz_4 = 2000;
-    metrix_length = 10;
-    loop_times = 100;
-    thread_num = 10;
-    //metrix = std::vector<std::vector<int>>(metrix_length, std::vector<int>(metrix_length, 0));
-  }
-  void TearDown() override {delete mma;}
-    size_t workload_sz_1;
-    size_t workload_sz_2;
-    size_t workload_sz_3;
-    size_t workload_sz_4;
-    int metrix_length;
-    int loop_times;
-    int thread_num;
-    proj3::MemoryManager * mma;
-    std::vector<std::vector<int>>metrix = {{ 2850, 2895, 2940, 2985, 3030, 3075, 3120, 3165, 3210, 3255 },
-    { 7350, 7495, 7640, 7785, 7930, 8075, 8220, 8365, 8510, 8655 },
-    { 11850, 12095, 12340, 12585, 12830, 13075, 13320, 13565, 13810, 14055 },
-    { 16350, 16695, 17040, 17385, 17730, 18075, 18420, 18765, 19110, 19455 },
-    { 20850, 21295, 21740, 22185, 22630, 23075, 23520, 23965, 24410, 24855 },
-    { 25350, 25895, 26440, 26985, 27530, 28075, 28620, 29165, 29710, 30255 },
-    { 29850, 30495, 31140, 31785, 32430, 33075, 33720, 34365, 35010, 35655 },
-    { 34350, 35095, 35840, 36585, 37330, 38075, 38820, 39565, 40310, 41055 },
-    { 38850, 39695, 40540, 41385, 42230, 43075, 43920, 44765, 45610, 46455 },
-    { 43350, 44295, 45240, 46185, 47130, 48075, 49020, 49965, 50910, 51855 },};
-};
-
-TEST_F(MMATest,task1){
-	proj3::ArrayList* arr = mma->Allocate(workload_sz_1);
-    for(unsigned long i = 0; i<workload_sz_1; i++){
-        arr->Write(i, 1);
-    }
-    for(unsigned long i = 0; i<workload_sz_1; i++){
-        EXPECT_EQ(1, arr->Read(i));
-    }
-    mma->Release(arr);
-}
-
-TEST_F(MMATest,task2){
-	std::vector<proj3::ArrayList*>arr;
-    for(int i = 0; i<loop_times; i++){
-        arr.push_back(mma->Allocate(workload_sz_2));
-        for(unsigned long j = 0; j < workload_sz_2; j++)arr[i]->Write(j, i);
-    }
-    for(int i = 0; i<loop_times; i++){
-        if(i %2)mma->Release(arr[i]);
-        else for(unsigned long j = 0; j < workload_sz_2; j++)EXPECT_EQ(i, arr[i]->Read(j));
-    }
-    for(int i = 0; i<loop_times; i++){
-        if(i %2 == 0)mma->Release(arr[i]);
-    }
-}
-
-TEST_F(MMATest,task3){
-	std::vector<proj3::ArrayList*>metrixA, metrixB, metrixC;
-    for(int i = 0; i<metrix_length; i++){
-        metrixA.push_back(mma->Allocate(metrix_length));
-        metrixB.push_back(mma->Allocate(metrix_length));
-        metrixC.push_back(mma->Allocate(metrix_length));
-        for(int j = 0; j < metrix_length; j++){
-            metrixA[i]->Write(j, i*metrix_length+j);
-            metrixB[i]->Write(j, i*metrix_length+j);
-        }
-    }
-    
-    for(int i = 0; i<metrix_length; i++){
-        for(int j = 0; j<metrix_length; j++){
-            for(int k = 0; k < metrix_length; k++){
-                metrixC[i]->Write(j, metrixC[i]->Read(j)+metrixA[i]->Read(k)*metrixB[k]->Read(j));
-            }
-        }
-    }
-
-    for(int i = 0; i<metrix_length; i++){
-        for(int j = 0; j<metrix_length; j++){
-            EXPECT_EQ(metrix[i][j], metrixC[i]->Read(j));
-        }
-    }
-
-    for(int i = 0; i<metrix_length; i++){
-        mma->Release(metrixA[i]);
-        mma->Release(metrixB[i]);
-        mma->Release(metrixC[i]);
-    }
-
-}
-
-void workload(proj3::MemoryManager * my_mma, size_t workload_sz){
-    proj3::ArrayList* arr = my_mma->Allocate(workload_sz);
-    for(unsigned long j = 0; j < workload_sz; j++)arr->Write(j, j);
-    for(unsigned long j = 0; j < workload_sz; j++)EXPECT_EQ(j, arr->Read(j));
-    my_mma->Release(arr);
-}
-
-TEST_F(MMATest,task4){
-    std::vector<std::thread*> pool;
-    for(int i = 0; i<thread_num; i++) {
-        pool.push_back(new std::thread(&workload, mma, workload_sz_4));
-    }
-
-    for (auto t: pool) {
-        t->join();
-    }
-}
-
-} // namespace testing
-} // namespace proj3
-
-int main(int argc,char **argv){
-  testing::InitGoogleTest(&argc,argv);
-  return RUN_ALL_TESTS();
-}
+#include <gtest/gtest.h>
+#include<vector>
+#include<thread>
+
+#include "lib/array_list.h"
+#include "lib/memory_manager.h"
+
+namespace proj3 {
+namespace testing{
+
+class MMATest : public ::testing::Test {
+ protected:
+  void SetUp() override {
+    mma = new proj3::MemoryManager(10);
+    workload_sz_1 = 4000; 
+    workload_sz_2 = 2000; 
+    workload_sz_3 = 100; 
+    workload_sz_4 = 2000;
+    metrix_length = 10;
+    loop_times = 100;
+    thread_num = 10;
+    //metrix = std::vector<std::vector<int>>(metrix_length, std::vector<int>(metrix_length, 0));
+  }
+  void TearDown() override {delete mma;}
+    size_t workload_sz_1;
+    size_t workload_sz_2;
+    size_t workload_sz_3;
+    size_t workload_sz_4;
+    int metrix_length;
+    int loop_times;
+    int thread_num;
+    proj3::MemoryManager * mma;
+    std::vector<std::vector<int>>metrix = {{ 2850, 2895, 2940, 2985, 3030, 3075, 3120, 3165, 3210, 3255 },
+    { 7350, 7495, 7640, 7785, 7930, 8075, 8220, 8365, 8510, 8655 },
+    { 11850, 12095, 12340, 12585, 12830, 13075, 13320, 13565, 13810, 14055 },
+    { 16350, 16695, 17040, 17385, 17730, 18075, 18420, 18765, 19110, 19455 },
+    { 20850, 21295, 21740, 22185, 22630, 23075, 23520, 23965, 24410, 24855 },
+    { 25350, 25895, 26440, 26985, 27530, 28075, 28620, 29165, 29710, 30255 },
+    { 29850, 30495, 31140, 31785, 32430, 33075, 33720, 34365, 35010, 35655 },
+    { 34350, 35095, 35840, 36585, 37330, 38075, 38820, 39565, 40310, 41055 },
+    { 38850, 39695, 40540, 41385, 42230, 43075, 43920, 44765, 45610, 46455 },
+    { 43350, 44295, 45240, 46185, 47130, 48075, 49020, 49965, 50910, 51855 },};
+};
+
+TEST_F(MMATest,task1){
+	proj3::ArrayList* arr = mma->Allocate(workload_sz_1);
+    for(unsigned long i = 0; i<workload_sz_1; i++){
+        arr->Write(i, 1);
+    }
+    for(unsigned long i = 0; i<workload_sz_1; i++){
+        EXPECT_EQ(1, arr->Read(i));
+    }
+    mma->Release(arr);
+}
+
+TEST_F(MMATest,task2){
+	std::vector<proj3::ArrayList*>arr;
+    for(int i = 0; i<loop_times; i++){
+        arr.push_back(mma->Allocate(workload_sz_2));
+        for(unsigned long j = 0; j < workload_sz_2; j++)arr[i]->Write(j, i);
+    }
+    for(int i = 0; i<loop_times; i++){
+        if(i %2)mma->Release(arr[i]);
+        else for(unsigned long j = 0; j < workload_sz_2; j++)EXPECT_EQ(i, arr[i]->Read(j));
+    }
+    for(int i = 0; i<loop_times; i++){
+        if(i %2 == 0)mma->Release(arr[i]);
+    }
+}
+
+TEST_F(MMATest,task3){
+	std::vector<proj3::ArrayList*>metrixA, metrixB, metrixC;
+    for(int i = 0; i<metrix_length; i++){
+        metrixA.push_back(mma->Allocate(metrix_length));
+        metrixB.push_back(mma->Allocate(metrix_length));
+        metrixC.push_back(mma->Allocate(metrix_length));
+        for(int j = 0; j < metrix_length; j++){
+            metrixA[i]->Write(j, i*metrix_length+j);
+            metrixB[i]->Write(j, i*metrix_length+j);
+        }
+    }
+    
+    for(int i = 0; i<metrix_length; i++){
+        for(int j = 0; j<metrix_length; j++){
+            for(int k = 0; k < metrix_length; k++){
+                metrixC[i]->Write(j, metrixC[i]->Read(j)+metrixA[i]->Read(k)*metrixB[k]->Read(j));
+            }
+        }
+    }
+
+    for(int i = 0; i<metrix_length; i++){
+        for(int j = 0; j<metrix_length; j++){
+            EXPECT_EQ(metrix[i][j], metrixC[i]->Read(j));
+        }
+    }
+
+    for(int i = 0; i<metrix_length; i++){
+        mma->Release(metrixA[i]);
+        mma->Release(metrixB[i]);
+        mma->Release(metrixC[i]);
+    }
+
+}
+
+void workload(proj3::MemoryManager * my_mma, size_t workload_sz){
+    proj3::ArrayList* arr = my_mma->Allocate(workload_sz);
+    for(unsigned long j = 0; j < workload_sz; j++)arr->Write(j, j);
+    for(unsigned long j = 0; j < workload_sz; j++)EXPECT_EQ(j, arr->Read(j));
+    my_mma->Release(arr);
+}
+
+TEST_F(MMATest,task4){
+    std::vector<std::thread*> pool;
+    for(int i = 0; i<thread_num; i++) {
+        pool.push_back(new std::thread(&workload, mma, workload_sz_4));
+    }
+
+    for (auto t: pool) {
+        t->join();
+    }
+}
+
+} // namespace testing
+} // namespace proj3
+
+int main(int argc,char **argv){
+  testing::InitGoogleTest(&argc,argv);
+  return RUN_ALL_TESTS();
+}
\ No newline at end of file
diff --git a/Memory/mma_tests.sh b/Memory/mma_tests.sh
new file mode 100755
index 0000000..5510b95
--- /dev/null
+++ b/Memory/mma_tests.sh
@@ -0,0 +1,4 @@
+bazel run q1
+bazel run q2
+bazel run q3
+bazel run q4
\ No newline at end of file
diff --git a/Memory/q1.cc b/Memory/q1.cc
new file mode 100644
index 0000000..0ef099c
--- /dev/null
+++ b/Memory/q1.cc
@@ -0,0 +1,112 @@
+#include <gtest/gtest.h>
+#include<vector>
+#include<thread>
+
+#include "lib/utils.h"
+#include "lib/array_list.h"
+#include "lib/memory_manager.h"
+
+// Modified from `mma_test.cc`, include tests required in Q1. 
+// 10ms `slow_function()` overhead each page replacement op. 
+
+namespace proj3 {
+namespace testing{
+
+class Q1 : public ::testing::Test {
+ protected:
+  void SetUp() override {
+    // Use FIFO replacement policy
+    mma = new proj3::MemoryManager(10, FIFO, false);
+    workload_sz_1 = 4000;
+    workload_sz_2 = 2000;
+    workload_sz_3 = 100;
+    metrix_length = 10;
+    loop_times = 100;
+  }
+  void TearDown() override {delete mma;}
+    size_t workload_sz_1;
+    size_t workload_sz_2;
+    size_t workload_sz_3;
+    int metrix_length;
+    int loop_times;
+    proj3::MemoryManager * mma;
+    std::vector<std::vector<int>>metrix = {
+        { 2850, 2895, 2940, 2985, 3030, 3075, 3120, 3165, 3210, 3255 },
+        { 7350, 7495, 7640, 7785, 7930, 8075, 8220, 8365, 8510, 8655 },
+        { 11850, 12095, 12340, 12585, 12830, 13075, 13320, 13565, 13810, 14055 },
+        { 16350, 16695, 17040, 17385, 17730, 18075, 18420, 18765, 19110, 19455 },
+        { 20850, 21295, 21740, 22185, 22630, 23075, 23520, 23965, 24410, 24855 },
+        { 25350, 25895, 26440, 26985, 27530, 28075, 28620, 29165, 29710, 30255 },
+        { 29850, 30495, 31140, 31785, 32430, 33075, 33720, 34365, 35010, 35655 },
+        { 34350, 35095, 35840, 36585, 37330, 38075, 38820, 39565, 40310, 41055 },
+        { 38850, 39695, 40540, 41385, 42230, 43075, 43920, 44765, 45610, 46455 },
+        { 43350, 44295, 45240, 46185, 47130, 48075, 49020, 49965, 50910, 51855 },
+    };
+};
+
+TEST_F(Q1,task1){
+	proj3::ArrayList* arr = mma->Allocate(workload_sz_1);
+    for(unsigned long i = 0; i<workload_sz_1; i++){
+        arr->Write(i, 1);
+    }
+    for(unsigned long i = 0; i<workload_sz_1; i++){
+        EXPECT_EQ(1, arr->Read(i));
+    }
+    mma->Release(arr);
+}
+
+TEST_F(Q1,task2){
+	std::vector<proj3::ArrayList*>arr;
+    for(int i = 0; i<loop_times; i++){
+        arr.push_back(mma->Allocate(workload_sz_2));
+        for(unsigned long j = 0; j < workload_sz_2; j++)arr[i]->Write(j, i);
+    }
+    for(int i = 0; i<loop_times; i++){
+        if(i %2)mma->Release(arr[i]);
+        else for(unsigned long j = 0; j < workload_sz_2; j++)EXPECT_EQ(i, arr[i]->Read(j));
+    }
+    for(int i = 0; i<loop_times; i++){
+        if(i %2 == 0)mma->Release(arr[i]);
+    }
+}
+
+TEST_F(Q1,task3){
+	std::vector<proj3::ArrayList*>metrixA, metrixB, metrixC;
+    for(int i = 0; i<metrix_length; i++){
+        metrixA.push_back(mma->Allocate(metrix_length));
+        metrixB.push_back(mma->Allocate(metrix_length));
+        metrixC.push_back(mma->Allocate(metrix_length));
+        for(int j = 0; j < metrix_length; j++){
+            metrixA[i]->Write(j, i*metrix_length+j);
+            metrixB[i]->Write(j, i*metrix_length+j);
+        }
+    }
+    
+    for(int i = 0; i<metrix_length; i++){
+        for(int j = 0; j<metrix_length; j++){
+            for(int k = 0; k < metrix_length; k++){
+                metrixC[i]->Write(j, metrixC[i]->Read(j)+metrixA[i]->Read(k)*metrixB[k]->Read(j));
+            }
+        }
+    }
+
+    for(int i = 0; i<metrix_length; i++){
+        for(int j = 0; j<metrix_length; j++){
+            EXPECT_EQ(metrix[i][j], metrixC[i]->Read(j));
+        }
+    }
+
+    for(int i = 0; i<metrix_length; i++){
+        mma->Release(metrixA[i]);
+        mma->Release(metrixB[i]);
+        mma->Release(metrixC[i]);
+    }
+}
+
+} // namespace testing
+} // namespace proj3
+
+int main(int argc,char **argv){
+  testing::InitGoogleTest(&argc,argv);
+  return RUN_ALL_TESTS();
+}
diff --git a/Memory/q2.cc b/Memory/q2.cc
new file mode 100644
index 0000000..7bd35de
--- /dev/null
+++ b/Memory/q2.cc
@@ -0,0 +1,112 @@
+#include <gtest/gtest.h>
+#include<vector>
+#include<thread>
+
+#include "lib/utils.h"
+#include "lib/array_list.h"
+#include "lib/memory_manager.h"
+
+// Modified from `mma_test.cc`, include tests required in Q2. 
+// 10ms `slow_function()` overhead each page replacement op. 
+
+namespace proj3 {
+namespace testing{
+
+class Q2 : public ::testing::Test {
+ protected:
+  void SetUp() override {
+    // Use CLOCk algorithm as replacement policy
+    mma = new proj3::MemoryManager(10, CLOCK, false);
+    workload_sz_1 = 4000;
+    workload_sz_2 = 2000;
+    workload_sz_3 = 100;
+    metrix_length = 10;
+    loop_times = 100;
+  }
+  void TearDown() override {delete mma;}
+    size_t workload_sz_1;
+    size_t workload_sz_2;
+    size_t workload_sz_3;
+    int metrix_length;
+    int loop_times;
+    proj3::MemoryManager * mma;
+    std::vector<std::vector<int>>metrix = {
+        { 2850, 2895, 2940, 2985, 3030, 3075, 3120, 3165, 3210, 3255 },
+        { 7350, 7495, 7640, 7785, 7930, 8075, 8220, 8365, 8510, 8655 },
+        { 11850, 12095, 12340, 12585, 12830, 13075, 13320, 13565, 13810, 14055 },
+        { 16350, 16695, 17040, 17385, 17730, 18075, 18420, 18765, 19110, 19455 },
+        { 20850, 21295, 21740, 22185, 22630, 23075, 23520, 23965, 24410, 24855 },
+        { 25350, 25895, 26440, 26985, 27530, 28075, 28620, 29165, 29710, 30255 },
+        { 29850, 30495, 31140, 31785, 32430, 33075, 33720, 34365, 35010, 35655 },
+        { 34350, 35095, 35840, 36585, 37330, 38075, 38820, 39565, 40310, 41055 },
+        { 38850, 39695, 40540, 41385, 42230, 43075, 43920, 44765, 45610, 46455 },
+        { 43350, 44295, 45240, 46185, 47130, 48075, 49020, 49965, 50910, 51855 },
+    };
+};
+
+TEST_F(Q2,task1){
+	proj3::ArrayList* arr = mma->Allocate(workload_sz_1);
+    for(unsigned long i = 0; i<workload_sz_1; i++){
+        arr->Write(i, 1);
+    }
+    for(unsigned long i = 0; i<workload_sz_1; i++){
+        EXPECT_EQ(1, arr->Read(i));
+    }
+    mma->Release(arr);
+}
+
+TEST_F(Q2,task2){
+	std::vector<proj3::ArrayList*>arr;
+    for(int i = 0; i<loop_times; i++){
+        arr.push_back(mma->Allocate(workload_sz_2));
+        for(unsigned long j = 0; j < workload_sz_2; j++)arr[i]->Write(j, i);
+    }
+    for(int i = 0; i<loop_times; i++){
+        if(i %2)mma->Release(arr[i]);
+        else for(unsigned long j = 0; j < workload_sz_2; j++)EXPECT_EQ(i, arr[i]->Read(j));
+    }
+    for(int i = 0; i<loop_times; i++){
+        if(i %2 == 0)mma->Release(arr[i]);
+    }
+}
+
+TEST_F(Q2,task3){
+	std::vector<proj3::ArrayList*>metrixA, metrixB, metrixC;
+    for(int i = 0; i<metrix_length; i++){
+        metrixA.push_back(mma->Allocate(metrix_length));
+        metrixB.push_back(mma->Allocate(metrix_length));
+        metrixC.push_back(mma->Allocate(metrix_length));
+        for(int j = 0; j < metrix_length; j++){
+            metrixA[i]->Write(j, i*metrix_length+j);
+            metrixB[i]->Write(j, i*metrix_length+j);
+        }
+    }
+    
+    for(int i = 0; i<metrix_length; i++){
+        for(int j = 0; j<metrix_length; j++){
+            for(int k = 0; k < metrix_length; k++){
+                metrixC[i]->Write(j, metrixC[i]->Read(j)+metrixA[i]->Read(k)*metrixB[k]->Read(j));
+            }
+        }
+    }
+
+    for(int i = 0; i<metrix_length; i++){
+        for(int j = 0; j<metrix_length; j++){
+            EXPECT_EQ(metrix[i][j], metrixC[i]->Read(j));
+        }
+    }
+
+    for(int i = 0; i<metrix_length; i++){
+        mma->Release(metrixA[i]);
+        mma->Release(metrixB[i]);
+        mma->Release(metrixC[i]);
+    }
+}
+
+} // namespace testing
+} // namespace proj3
+
+int main(int argc,char **argv){
+  testing::InitGoogleTest(&argc,argv);
+  return RUN_ALL_TESTS();
+}
diff --git a/Memory/q3.cc b/Memory/q3.cc
new file mode 100644
index 0000000..66e1206
--- /dev/null
+++ b/Memory/q3.cc
@@ -0,0 +1,79 @@
+#include <gtest/gtest.h>
+#include <vector>
+#include <thread>
+#include <string>
+#include <iostream>
+
+#include "lib/utils.h"
+#include "lib/array_list.h"
+#include "lib/memory_manager.h"
+
+// Modified from `mma_test.cc`, include tests required in Q3. 
+// 10ms `slow_function()` overhead each page replacement op. 
+
+namespace proj3 {
+namespace testing{
+
+class Q3 : public ::testing::Test {
+ protected:
+  void SetUp() override {
+    range = 10;
+    for (int i=1; i<=range; i++) {
+        // Use FIFO Algorithm as replacement policy
+        mma.push_back(new proj3::MemoryManager(i, FIFO, false));
+        // Use CLOCk algorithm as replacement policy
+        mma_clock.push_back(new proj3::MemoryManager(i, CLOCK, false));
+    }
+    
+    workload_sz_2 = 2000;
+    loop_times = 100;
+  }
+  void TearDown() override {
+      for (int i=0; i<range; i++){
+          delete mma[i];
+          delete mma_clock[i];
+      }
+  }
+    size_t workload_sz_2;
+    int loop_times;
+    int range;
+    std::vector<proj3::MemoryManager *> mma;
+    std::vector<proj3::MemoryManager *> mma_clock;
+};
+
+int task2(proj3::MemoryManager * mma, size_t workload_sz_2, int loop_times) {
+    auto start = std::chrono::high_resolution_clock::now();
+    std::vector<proj3::ArrayList*>arr;
+    for(int i = 0; i<loop_times; i++){
+        arr.push_back(mma->Allocate(workload_sz_2));
+        for(unsigned long j = 0; j < workload_sz_2; j++)arr[i]->Write(j, i);
+    }
+    for(int i = 0; i<loop_times; i++){
+        if(i %2)mma->Release(arr[i]);
+        else for(unsigned long j = 0; j < workload_sz_2; j++)EXPECT_EQ(i, arr[i]->Read(j));
+    }
+    for(int i = 0; i<loop_times; i++){
+        if(i %2 == 0)mma->Release(arr[i]);
+    }
+    auto end = std::chrono::high_resolution_clock::now();
+    // auto dur = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
+    auto dur = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
+    return dur.count();
+}
+
+TEST_F(Q3,task2){
+    for (int i=0; i<range; i++){
+        int dur_1 = task2(mma[i], workload_sz_2, loop_times);
+        int dur_2 = task2(mma_clock[i], workload_sz_2, loop_times);
+        // printf("%d FIFO %d us\tCLOCK %d us\n", i+1, dur_1, dur_2);
+        printf("%d FIFO %d ms\tCLOCK %d ms\n", i+1, dur_1, dur_2);
+    }
+}
+
+} // namespace testing
+} // namespace proj3
+
+int main(int argc,char **argv){
+  testing::InitGoogleTest(&argc,argv);
+  return RUN_ALL_TESTS();
+}
diff --git a/Memory/q4.cc b/Memory/q4.cc
new file mode 100644
index 0000000..85c3119
--- /dev/null
+++ b/Memory/q4.cc
@@ -0,0 +1,74 @@
+#include <gtest/gtest.h>
+#include <vector>
+#include <thread>
+#include <string>
+#include <iostream>
+
+#include "lib/utils.h"
+#include "lib/array_list.h"
+#include "lib/memory_manager.h"
+
+// Modified from `mma_test.cc`, include tests required in Q4. 
+// 10ms `slow_function()` overhead each page replacement op. 
+
+namespace proj3 {
+namespace testing{
+
+class Q4 : public ::testing::Test {
+ protected:
+  void SetUp() override {
+    // Use CLOCk algorithm as replacement policy
+    mma_clock = new proj3::MemoryManager(10, CLOCK, false);
+    workload_sz_4 = 2000;
+    range = 10;
+    for (int i=10; i<=10+range; i++) {
+        thread_num.push_back(i);  
+    }
+  }
+  void TearDown() override {delete mma_clock;}
+    int range;
+    size_t workload_sz_4;
+    std::vector<int> thread_num;
+    proj3::MemoryManager * mma_clock;
+};
+
+void workload(proj3::MemoryManager * my_mma, size_t workload_sz){
+    proj3::ArrayList* arr = my_mma->Allocate(workload_sz);
+    for(unsigned long j = 0; j < workload_sz; j++)arr->Write(j, j);
+    for(unsigned long j = 0; j < workload_sz; j++)EXPECT_EQ(j, arr->Read(j));
+    my_mma->Release(arr);
+}
+
+int task4(proj3::MemoryManager * mma, size_t workload_sz_4, int thread_num) {
+    auto start = std::chrono::high_resolution_clock::now();
+
+    std::vector<std::thread*> pool;
+    for(int i = 0; i<thread_num; i++) {
+        pool.push_back(new std::thread(&workload, mma, workload_sz_4));
+    }
+
+    for (auto t: pool) {
+        t->join();
+    }
+
+    auto end = std::chrono::high_resolution_clock::now();
+    // auto dur = std::chrono::duration_cast<std::chrono::microseconds>(end - start);
+    auto dur = std::chrono::duration_cast<std::chrono::milliseconds>(end - start);
+    return dur.count();
+}
+
+TEST_F(Q4,task4){
+    for (int i=0; i<=range; i++){
+        int dur = task4(mma_clock, workload_sz_4, thread_num[i]);
+        // printf("Allocation %d\tCLOCK %d us\n", i+1, dur);
+        printf("Thread # %d\tCLOCK %d ms\n", i+10, dur);
+    }
+}
+
+} // namespace testing
+} // namespace proj3
+
+int main(int argc,char **argv){
+  testing::InitGoogleTest(&argc,argv);
+  return RUN_ALL_TESTS();
+}
diff --git a/Memory/test_results.txt b/Memory/test_results.txt
new file mode 100644
index 0000000..55876b3
--- /dev/null
+++ b/Memory/test_results.txt
@@ -0,0 +1,81 @@
+exec ${PAGER:-/usr/bin/less} "$0" || exit 1
+Executing tests from //:q1
+-----------------------------------------------------------------------------
+[==========] Running 3 tests from 1 test suite.
+[----------] Global test environment set-up.
+[----------] 3 tests from Q1
+[ RUN      ] Q1.task1
+[       OK ] Q1.task1 (23 ms)
+[ RUN      ] Q1.task2
+[       OK ] Q1.task2 (852 ms)
+[ RUN      ] Q1.task3
+[       OK ] Q1.task3 (21 ms)
+[----------] 3 tests from Q1 (897 ms total)
+
+[----------] Global test environment tear-down
+[==========] 3 tests from 1 test suite ran. (897 ms total)
+[  PASSED  ] 3 tests.
+exec ${PAGER:-/usr/bin/less} "$0" || exit 1
+Executing tests from //:q2
+-----------------------------------------------------------------------------
+[==========] Running 3 tests from 1 test suite.
+[----------] Global test environment set-up.
+[----------] 3 tests from Q2
+[ RUN      ] Q2.task1
+[       OK ] Q2.task1 (23 ms)
+[ RUN      ] Q2.task2
+[       OK ] Q2.task2 (827 ms)
+[ RUN      ] Q2.task3
+[       OK ] Q2.task3 (17 ms)
+[----------] 3 tests from Q2 (868 ms total)
+
+[----------] Global test environment tear-down
+[==========] 3 tests from 1 test suite ran. (868 ms total)
+[  PASSED  ] 3 tests.
+exec ${PAGER:-/usr/bin/less} "$0" || exit 1
+Executing tests from //:q3
+-----------------------------------------------------------------------------
+[==========] Running 1 test from 1 test suite.
+[----------] Global test environment set-up.
+[----------] 1 test from Q3
+[ RUN      ] Q3.task2
+1 FIFO 891 ms	CLOCK 795 ms
+2 FIFO 775 ms	CLOCK 813 ms
+3 FIFO 795 ms	CLOCK 895 ms
+4 FIFO 799 ms	CLOCK 799 ms
+5 FIFO 767 ms	CLOCK 786 ms
+6 FIFO 777 ms	CLOCK 778 ms
+7 FIFO 784 ms	CLOCK 800 ms
+8 FIFO 786 ms	CLOCK 793 ms
+9 FIFO 784 ms	CLOCK 775 ms
+10 FIFO 785 ms	CLOCK 798 ms
+[       OK ] Q3.task2 (15988 ms)
+[----------] 1 test from Q3 (15988 ms total)
+
+[----------] Global test environment tear-down
+[==========] 1 test from 1 test suite ran. (15988 ms total)
+[  PASSED  ] 1 test.
+exec ${PAGER:-/usr/bin/less} "$0" || exit 1
+Executing tests from //:q4
+-----------------------------------------------------------------------------
+[==========] Running 1 test from 1 test suite.
+[----------] Global test environment set-up.
+[----------] 1 test from Q4
+[ RUN      ] Q4.task4
+Thread # 10	CLOCK 448 ms
+Thread # 11	CLOCK 559 ms
+Thread # 12	CLOCK 688 ms
+Thread # 13	CLOCK 875 ms
+Thread # 14	CLOCK 963 ms
+Thread # 15	CLOCK 1037 ms
+Thread # 16	CLOCK 1086 ms
+Thread # 17	CLOCK 1367 ms
+Thread # 18	CLOCK 1504 ms
+Thread # 19	CLOCK 1553 ms
+Thread # 20	CLOCK 1691 ms
+[       OK ] Q4.task4 (11777 ms)
+[----------] 1 test from Q4 (11777 ms total)
+
+[----------] Global test environment tear-down
+[==========] 1 test from 1 test suite ran. (11777 ms total)
+[  PASSED  ] 1 test.
diff --git a/Memory/test_results_10ms.txt b/Memory/test_results_10ms.txt
new file mode 100644
index 0000000..e787825
--- /dev/null
+++ b/Memory/test_results_10ms.txt
@@ -0,0 +1,81 @@
+exec ${PAGER:-/usr/bin/less} "$0" || exit 1
+Executing tests from //:q1
+-----------------------------------------------------------------------------
+[==========] Running 3 tests from 1 test suite.
+[----------] Global test environment set-up.
+[----------] 3 tests from Q1
+[ RUN      ] Q1.task1
+[       OK ] Q1.task1 (446 ms)
+[ RUN      ] Q1.task2
+[       OK ] Q1.task2 (53561 ms)
+[ RUN      ] Q1.task3
+[       OK ] Q1.task3 (141405 ms)
+[----------] 3 tests from Q1 (195413 ms total)
+
+[----------] Global test environment tear-down
+[==========] 3 tests from 1 test suite ran. (195413 ms total)
+[  PASSED  ] 3 tests.
+exec ${PAGER:-/usr/bin/less} "$0" || exit 1
+Executing tests from //:q2
+-----------------------------------------------------------------------------
+[==========] Running 3 tests from 1 test suite.
+[----------] Global test environment set-up.
+[----------] 3 tests from Q2
+[ RUN      ] Q2.task1
+[       OK ] Q2.task1 (442 ms)
+[ RUN      ] Q2.task2
+[       OK ] Q2.task2 (53509 ms)
+[ RUN      ] Q2.task3
+[       OK ] Q2.task3 (108617 ms)
+[----------] 3 tests from Q2 (162569 ms total)
+
+[----------] Global test environment tear-down
+[==========] 3 tests from 1 test suite ran. (162569 ms total)
+[  PASSED  ] 3 tests.
+exec ${PAGER:-/usr/bin/less} "$0" || exit 1
+Executing tests from //:q3
+-----------------------------------------------------------------------------
+[==========] Running 1 test from 1 test suite.
+[----------] Global test environment set-up.
+[----------] 1 test from Q3
+[ RUN      ] Q3.task2
+1 FIFO 53547 ms	CLOCK 53621 ms
+2 FIFO 53591 ms	CLOCK 53568 ms
+3 FIFO 53575 ms	CLOCK 53557 ms
+4 FIFO 53614 ms	CLOCK 53564 ms
+5 FIFO 53423 ms	CLOCK 53507 ms
+6 FIFO 53505 ms	CLOCK 53526 ms
+7 FIFO 53511 ms	CLOCK 53535 ms
+8 FIFO 53588 ms	CLOCK 53531 ms
+9 FIFO 53559 ms	CLOCK 53544 ms
+10 FIFO 53579 ms	CLOCK 53584 ms
+[       OK ] Q3.task2 (1071046 ms)
+[----------] 1 test from Q3 (1071046 ms total)
+
+[----------] Global test environment tear-down
+[==========] 1 test from 1 test suite ran. (1071046 ms total)
+[  PASSED  ] 1 test.
+exec ${PAGER:-/usr/bin/less} "$0" || exit 1
+Executing tests from //:q4
+-----------------------------------------------------------------------------
+[==========] Running 1 test from 1 test suite.
+[----------] Global test environment set-up.
+[----------] 1 test from Q4
+[ RUN      ] Q4.task4
+Thread # 10	CLOCK 1731 ms
+Thread # 11	CLOCK 2337 ms
+Thread # 12	CLOCK 2877 ms
+Thread # 13	CLOCK 4267 ms
+Thread # 14	CLOCK 4780 ms
+Thread # 15	CLOCK 5866 ms
+Thread # 16	CLOCK 8302 ms
+Thread # 17	CLOCK 14321 ms
+Thread # 18	CLOCK 22674 ms
+Thread # 19	CLOCK 102280 ms
+Thread # 20	CLOCK 1204060 ms
+[       OK ] Q4.task4 (1373502 ms)
+[----------] 1 test from Q4 (1373502 ms total)
+
+[----------] Global test environment tear-down
+[==========] 1 test from 1 test suite ran. (1373502 ms total)
+[  PASSED  ] 1 test.
diff --git a/RPC/.bazeliskrc b/RPC/.bazeliskrc
new file mode 100644
index 0000000..f81d3f7
--- /dev/null
+++ b/RPC/.bazeliskrc
@@ -0,0 +1 @@
+USE_BAZEL_VERSION=4.2.1
diff --git a/RPC/BUILD b/RPC/BUILD
new file mode 100644
index 0000000..865d44b
--- /dev/null
+++ b/RPC/BUILD
@@ -0,0 +1,20 @@
+##load("@rules_cc//cc:defs.bzl", "cc_test")  #load the test target
+
+
+cc_test(
+    name = "mma_test",
+    size = "small",
+    srcs = ["mma_test.cc"],
+    deps = [
+        "@gtest//:gtest_main",
+        "@com_github_grpc_grpc//:grpc++",
+        "//lib:mma_client_lib",
+        "//lib:mma_server_lib",
+        ],
+    copts = [
+        "-std=c++11",
+    ],
+    linkopts = [
+        "-pthread",
+    ]
+)
\ No newline at end of file
diff --git a/RPC/README.md b/RPC/README.md
new file mode 100644
index 0000000..85233d7
--- /dev/null
+++ b/RPC/README.md
@@ -0,0 +1,55 @@
+# Remote Memory Management Service
+
+In this project, you will upgrade your memory manager from Project 3 and turn it into an in-memory storage server.   The server allows multiple clients to access it using RPC.  Specifically, we will use **grpc**, an open-source RPC system developed by Google. 
+
+The project's main goal is to let you get some hands-on experience on RPC.  You will learn how the framework works in general and similarities/differences from local procedure calls. 
+
+The server you develop will allow clients to create a "remote ArrayList", and use it using the same function calls as the local array in your project 3. 
+
+Your RPC client can allocate, access, and release memory from applications as requests to the server (i.e., manage `ArrayList` like `mma` in project 3); Moreover, there should be an RPC server holding the `mma` to receive and process these requests. 
+
+gRPC (gRPC Remote Procedure Calls), also known as Google Remote Procedure Call, is an open-source remote procedure call (RPC) system initially developed at Google. You can find a basic tutorial of grpc at 
+
+https://grpc.io/docs/languages/cpp/quickstart/ . 
+
+You can also download source codes from 
+https://github.com/grpc/grpc 
+for more details about grpc. 
+
+In this project, we will build and utilize grpc source codes by Bazel.  We have already added the necessary dependencies in your WORKSPACE file.  You do not need to change them.  Note that it might take a while to download all these dependencies the first time you build the project, but subsequent builds will be fast. 
+
+We can define a gRPC service (and its message structure) in a `.proto` file and automatically generate client and server codes. We use the proto3 version of the protocol buffers language in this project. You can find out more about protobuf at 
+
+https://developers.google.com/protocol-buffers/docs/proto3 
+
+and learn how to generate codes from a `.proto` file in 
+
+https://developers.google.com/protocol-buffers/docs/reference/cpp-generated 
+
+In this project, you do not have to manually generate and compile the protobuf's, as the Bazel rules will build them for you.  We have provided a  HelloWorld demo in the `demo` folder to help you understand the Bazel `BUILD` rules for a protobuf application.
+
+## Codebase Introduction
+
+The basic workload in this project is similar to the ones in project 3. The only difference is that the application `Allocate` and `Free` an `ArrayList` via your gRPC client instead of the `mma` directly. Similarly, an `ArrayList` should `read` / `write` its corresponding memory via the client. **On the other hand, each test will set up a gRPC server initially listening to the local port 50051. This server will create a `mma` instance in its lifetime to manage local memory space. Your gRPC server should support two basic management interfaces: `RunServerUL` for server setup and `ShutdownServer` to close the server.** We provide a basic skeleton of client/server in `mma_client.h` and `mma_server.h`. You can find more interfaces utilization examples in `mma_test.cc`.
+
+
+## TODO
+
+## Q1
+
+The first four tests in `mma_test.cc` are the same as in Project 3. Implement your gRPC client/server to pass these four tests. The page replacement algorithm should be the clock algorithm. First, you can copy your `mma` codes from project 3 to the `lib/`folder. Adjust some interfaces in your original implementation to adapt the `MemoryManager` and `ArrayList` implementation to RPC. To generate gRPC client/server codes, you should define your memory management service in `proto/mma.proto`. Your implementation should be thread-safe and support concurrency.  
+
+## Q2
+
+When the virtual memory space in use is far larger than the physical memory space of `mma`, thrashing happens and hurts system performance. To avoid thrashing, the memory management service should limit the virtual memory size and reject new incoming `Allocate` requests when existing virtual memory usage reaches the limits. Correspondingly, the client should wait and retry if its `Allocate` request fails until the required memory segment has been registered in the server. Implement this optimization and support an additional management interface: `RunServerL` for server setup with a given threshold of maximum virtual memory size. Pass the fifth test and observe its differences with `task4`.
+
+
+
+## Grading
+
+We will use extra workloads to test your codes, so your implementation should not rely on `mma_test.cc`. We grade with the following three requirements:
+
+1. Correctness: pass all tests in  `mma_test.cc` and extra tests;
+2. Performance: we will consider the time it takes to pass the tests. Your implementation should not be order-wisely slower than our basic benchmark.  
+
+We should apply your diff file to commit `fc85448` directly; otherwise, the TAs will not grade it. 
diff --git a/RPC/WORKSPACE b/RPC/WORKSPACE
new file mode 100644
index 0000000..5a1e506
--- /dev/null
+++ b/RPC/WORKSPACE
@@ -0,0 +1,43 @@
+load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
+
+## google test dependency
+http_archive(
+  name = "gtest",
+  urls = ["https://github.com.cnpmjs.org/google/googletest/archive/refs/tags/release-1.11.0.zip"],
+  strip_prefix = "googletest-release-1.11.0",
+)
+## google benchmark dependency
+http_archive(
+  name = "gbench",
+  urls = ["https://github.com.cnpmjs.org/google/benchmark/archive/refs/tags/v1.6.0.zip"],
+  strip_prefix = "benchmark-1.6.0",
+  sha256 = "3da225763533aa179af8438e994842be5ca72e4a7fed4d7976dc66c8c4502f58"
+)
+## protobuf dependency
+http_archive(
+    name = "rules_proto",
+    sha256 = "66bfdf8782796239d3875d37e7de19b1d94301e8972b3cbd2446b332429b4df1",
+    strip_prefix = "rules_proto-4.0.0",
+    urls = [
+        "https://mirror.bazel.build/github.com/bazelbuild/rules_proto/archive/refs/tags/4.0.0.tar.gz",
+        "https://github.com/bazelbuild/rules_proto/archive/refs/tags/4.0.0.tar.gz",
+    ],
+)
+load("@rules_proto//proto:repositories.bzl", "rules_proto_dependencies", "rules_proto_toolchains")
+rules_proto_dependencies()
+rules_proto_toolchains()
+
+
+### gRPC Rules for Bazel
+http_archive(
+    name = "com_github_grpc_grpc",
+    urls = [
+        "https://github.com.cnpmjs.org/grpc/grpc/archive/11f00485aa5ad422cfe2d9d90589158f46954101.tar.gz",
+    ],
+    strip_prefix = "grpc-11f00485aa5ad422cfe2d9d90589158f46954101",
+)
+load("@com_github_grpc_grpc//bazel:grpc_deps.bzl", "grpc_deps")
+grpc_deps()
+# Not mentioned in official docs... mentioned here https://github.com/grpc/grpc/issues/20511
+load("@com_github_grpc_grpc//bazel:grpc_extra_deps.bzl", "grpc_extra_deps")
+grpc_extra_deps()
\ No newline at end of file
diff --git a/RPC/demo/.bazeliskrc b/RPC/demo/.bazeliskrc
new file mode 100644
index 0000000..f81d3f7
--- /dev/null
+++ b/RPC/demo/.bazeliskrc
@@ -0,0 +1 @@
+USE_BAZEL_VERSION=4.2.1
diff --git a/RPC/demo/BUILD b/RPC/demo/BUILD
new file mode 100644
index 0000000..47fe9cf
--- /dev/null
+++ b/RPC/demo/BUILD
@@ -0,0 +1,21 @@
+cc_binary(
+    name = "greeter_client",
+    srcs = ["greeter_client.cc"],
+    defines = ["BAZEL_BUILD"],
+    deps = [
+        "@com_github_grpc_grpc//:grpc++",
+        "@com_github_grpc_grpc//:grpc++_reflection",
+        "//proto:hw_grpc",
+    ],
+)
+
+cc_binary(
+    name = "greeter_server",
+    srcs = ["greeter_server.cc"],
+    defines = ["BAZEL_BUILD"],
+    deps = [
+        "@com_github_grpc_grpc//:grpc++",
+        "@com_github_grpc_grpc//:grpc++_reflection",
+        "//proto:hw_grpc",
+    ],
+)
\ No newline at end of file
diff --git a/RPC/demo/WORKSPACE b/RPC/demo/WORKSPACE
new file mode 100644
index 0000000..5a1e506
--- /dev/null
+++ b/RPC/demo/WORKSPACE
@@ -0,0 +1,43 @@
+load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
+
+## google test dependency
+http_archive(
+  name = "gtest",
+  urls = ["https://github.com.cnpmjs.org/google/googletest/archive/refs/tags/release-1.11.0.zip"],
+  strip_prefix = "googletest-release-1.11.0",
+)
+## google benchmark dependency
+http_archive(
+  name = "gbench",
+  urls = ["https://github.com.cnpmjs.org/google/benchmark/archive/refs/tags/v1.6.0.zip"],
+  strip_prefix = "benchmark-1.6.0",
+  sha256 = "3da225763533aa179af8438e994842be5ca72e4a7fed4d7976dc66c8c4502f58"
+)
+## protobuf dependency
+http_archive(
+    name = "rules_proto",
+    sha256 = "66bfdf8782796239d3875d37e7de19b1d94301e8972b3cbd2446b332429b4df1",
+    strip_prefix = "rules_proto-4.0.0",
+    urls = [
+        "https://mirror.bazel.build/github.com/bazelbuild/rules_proto/archive/refs/tags/4.0.0.tar.gz",
+        "https://github.com/bazelbuild/rules_proto/archive/refs/tags/4.0.0.tar.gz",
+    ],
+)
+load("@rules_proto//proto:repositories.bzl", "rules_proto_dependencies", "rules_proto_toolchains")
+rules_proto_dependencies()
+rules_proto_toolchains()
+
+
+### gRPC Rules for Bazel
+http_archive(
+    name = "com_github_grpc_grpc",
+    urls = [
+        "https://github.com.cnpmjs.org/grpc/grpc/archive/11f00485aa5ad422cfe2d9d90589158f46954101.tar.gz",
+    ],
+    strip_prefix = "grpc-11f00485aa5ad422cfe2d9d90589158f46954101",
+)
+load("@com_github_grpc_grpc//bazel:grpc_deps.bzl", "grpc_deps")
+grpc_deps()
+# Not mentioned in official docs... mentioned here https://github.com/grpc/grpc/issues/20511
+load("@com_github_grpc_grpc//bazel:grpc_extra_deps.bzl", "grpc_extra_deps")
+grpc_extra_deps()
\ No newline at end of file
diff --git a/RPC/demo/greeter_client.cc b/RPC/demo/greeter_client.cc
new file mode 100644
index 0000000..30c7c15
--- /dev/null
+++ b/RPC/demo/greeter_client.cc
@@ -0,0 +1,108 @@
+/*
+ *
+ * Copyright 2015 gRPC authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#include <iostream>
+#include <memory>
+#include <string>
+
+#include <grpcpp/grpcpp.h>
+
+#ifdef BAZEL_BUILD
+#include "proto/helloworld.grpc.pb.h"
+#else
+#include "helloworld.grpc.pb.h"
+#endif
+
+using grpc::Channel;
+using grpc::ClientContext;
+using grpc::Status;
+using helloworld::Greeter;
+using helloworld::HelloReply;
+using helloworld::HelloRequest;
+
+class GreeterClient {
+ public:
+  GreeterClient(std::shared_ptr<Channel> channel)
+      : stub_(Greeter::NewStub(channel)) {}
+
+  // Assembles the client's payload, sends it and presents the response back
+  // from the server.
+  std::string SayHello(const std::string& user) {
+    // Data we are sending to the server.
+    HelloRequest request;
+    request.set_name(user);
+
+    // Container for the data we expect from the server.
+    HelloReply reply;
+
+    // Context for the client. It could be used to convey extra information to
+    // the server and/or tweak certain RPC behaviors.
+    ClientContext context;
+
+    // The actual RPC.
+    Status status = stub_->SayHello(&context, request, &reply);
+
+    // Act upon its status.
+    if (status.ok()) {
+      return reply.message();
+    } else {
+      std::cout << status.error_code() << ": " << status.error_message()
+                << std::endl;
+      return "RPC failed";
+    }
+  }
+
+ private:
+  std::unique_ptr<Greeter::Stub> stub_;
+};
+
+int main(int argc, char** argv) {
+  // Instantiate the client. It requires a channel, out of which the actual RPCs
+  // are created. This channel models a connection to an endpoint specified by
+  // the argument "--target=" which is the only expected argument.
+  // We indicate that the channel isn't authenticated (use of
+  // InsecureChannelCredentials()).
+  std::string target_str;
+  std::string arg_str("--target");
+  if (argc > 1) {
+    std::string arg_val = argv[1];
+    size_t start_pos = arg_val.find(arg_str);
+    if (start_pos != std::string::npos) {
+      start_pos += arg_str.size();
+      if (arg_val[start_pos] == '=') {
+        target_str = arg_val.substr(start_pos + 1);
+      } else {
+        std::cout << "The only correct argument syntax is --target="
+                  << std::endl;
+        return 0;
+      }
+    } else {
+      std::cout << "The only acceptable argument is --target=" << std::endl;
+      return 0;
+    }
+  } else {
+    target_str = "localhost:50051";
+  }
+  GreeterClient greeter(
+      grpc::CreateChannel(target_str, grpc::InsecureChannelCredentials()));
+  std::string user("world");
+  std::string reply = greeter.SayHello(user);
+  std::cout << "Greeter received: " << reply << std::endl;
+
+  return 0;
+}
diff --git a/RPC/demo/greeter_server.cc b/RPC/demo/greeter_server.cc
new file mode 100644
index 0000000..ebf6546
--- /dev/null
+++ b/RPC/demo/greeter_server.cc
@@ -0,0 +1,76 @@
+/*
+ *
+ * Copyright 2015 gRPC authors.
+ *
+ * Licensed under the Apache License, Version 2.0 (the "License");
+ * you may not use this file except in compliance with the License.
+ * You may obtain a copy of the License at
+ *
+ *     http://www.apache.org/licenses/LICENSE-2.0
+ *
+ * Unless required by applicable law or agreed to in writing, software
+ * distributed under the License is distributed on an "AS IS" BASIS,
+ * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+ * See the License for the specific language governing permissions and
+ * limitations under the License.
+ *
+ */
+
+#include <iostream>
+#include <memory>
+#include <string>
+
+#include <grpcpp/ext/proto_server_reflection_plugin.h>
+#include <grpcpp/grpcpp.h>
+#include <grpcpp/health_check_service_interface.h>
+
+#ifdef BAZEL_BUILD
+#include "proto/helloworld.grpc.pb.h"
+#else
+#include "helloworld.grpc.pb.h"
+#endif
+
+using grpc::Server;
+using grpc::ServerBuilder;
+using grpc::ServerContext;
+using grpc::Status;
+using helloworld::Greeter;
+using helloworld::HelloReply;
+using helloworld::HelloRequest;
+
+// Logic and data behind the server's behavior.
+class GreeterServiceImpl final : public Greeter::Service {
+  Status SayHello(ServerContext* context, const HelloRequest* request,
+                  HelloReply* reply) override {
+    std::string prefix("Hello ");
+    reply->set_message(prefix + request->name());
+    return Status::OK;
+  }
+};
+
+void RunServer() {
+  std::string server_address("0.0.0.0:50051");
+  GreeterServiceImpl service;
+
+  grpc::EnableDefaultHealthCheckService(true);
+  grpc::reflection::InitProtoReflectionServerBuilderPlugin();
+  ServerBuilder builder;
+  // Listen on the given address without any authentication mechanism.
+  builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
+  // Register "service" as the instance through which we'll communicate with
+  // clients. In this case it corresponds to an *synchronous* service.
+  builder.RegisterService(&service);
+  // Finally assemble the server.
+  std::unique_ptr<Server> server(builder.BuildAndStart());
+  std::cout << "Server listening on " << server_address << std::endl;
+
+  // Wait for the server to shutdown. Note that some other thread must be
+  // responsible for shutting down the server for this call to ever return.
+  server->Wait();
+}
+
+int main(int argc, char** argv) {
+  RunServer();
+
+  return 0;
+}
diff --git a/RPC/demo/proto/BUILD b/RPC/demo/proto/BUILD
new file mode 100644
index 0000000..4b95955
--- /dev/null
+++ b/RPC/demo/proto/BUILD
@@ -0,0 +1,23 @@
+package(default_visibility = ["//visibility:public"])
+
+load("@rules_proto//proto:defs.bzl", "proto_library")
+load("@com_github_grpc_grpc//bazel:cc_grpc_library.bzl", "cc_grpc_library")
+
+
+
+cc_grpc_library(
+    name = "hw_grpc",
+    srcs = [":hw_proto"],
+    grpc_only = True,
+    deps = [":hw_cc_proto"],
+)
+ 
+cc_proto_library(
+    name = "hw_cc_proto",
+    deps = [":hw_proto"],
+)
+ 
+proto_library(
+    name = "hw_proto",
+	srcs = ["helloworld.proto"],
+)
\ No newline at end of file
diff --git a/RPC/demo/proto/helloworld.proto b/RPC/demo/proto/helloworld.proto
new file mode 100644
index 0000000..be878ce
--- /dev/null
+++ b/RPC/demo/proto/helloworld.proto
@@ -0,0 +1,38 @@
+// Copyright 2015 gRPC authors.
+//
+// Licensed under the Apache License, Version 2.0 (the "License");
+// you may not use this file except in compliance with the License.
+// You may obtain a copy of the License at
+//
+//     http://www.apache.org/licenses/LICENSE-2.0
+//
+// Unless required by applicable law or agreed to in writing, software
+// distributed under the License is distributed on an "AS IS" BASIS,
+// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+// See the License for the specific language governing permissions and
+// limitations under the License.
+
+syntax = "proto3";
+
+option java_multiple_files = true;
+option java_package = "io.grpc.examples.helloworld";
+option java_outer_classname = "HelloWorldProto";
+option objc_class_prefix = "HLW";
+
+package helloworld;
+
+// The greeting service definition.
+service Greeter {
+  // Sends a greeting
+  rpc SayHello (HelloRequest) returns (HelloReply) {}
+}
+
+// The request message containing the user's name.
+message HelloRequest {
+  string name = 1;
+}
+
+// The response message containing the greetings
+message HelloReply {
+  string message = 1;
+}
diff --git a/RPC/lib/BUILD b/RPC/lib/BUILD
new file mode 100644
index 0000000..25d29fe
--- /dev/null
+++ b/RPC/lib/BUILD
@@ -0,0 +1,68 @@
+package(default_visibility = ["//visibility:public"])
+
+cc_library(
+    name = "mma_client_lib",
+    srcs = [
+        "mma_client.cc",
+        "array_list.cc",
+    ],
+    hdrs = [
+        "mma_client.h",
+        "array_list.h",
+        ],
+    defines = ["BAZEL_BUILD"],
+    deps = [
+        "@com_github_grpc_grpc//:grpc++",
+        "@com_github_grpc_grpc//:grpc++_reflection",
+        "//proto:mma_grpc",
+    ],
+)
+
+cc_library(
+    name = "mma_server_lib",
+    srcs = [
+        "mma_server.cc",
+        "memory_manager.cc",
+    ],
+    hdrs = [
+        "mma_server.h",
+        "memory_manager.h",
+        ],
+    defines = ["BAZEL_BUILD"],
+    deps = [
+        "@com_github_grpc_grpc//:grpc++",
+        "@com_github_grpc_grpc//:grpc++_reflection",
+        "//proto:mma_grpc",
+        "semaphore",
+    ],
+)
+
+cc_library(
+    name = "utils_lib",
+    srcs = [
+        "utils.cc",
+        ],
+    hdrs = [
+        "utils.h",
+        ],
+)
+
+cc_library(
+    name = "semaphore",
+    srcs = [
+        "semaphore.cc",
+        ],
+    hdrs = [
+        "semaphore.h",
+        ],
+	visibility = [
+		"//visibility:public",
+	],
+    copts = [
+        "-O3",
+        "-std=c++11",
+    ],
+	linkopts = [
+        "-pthread",
+    ],
+)
diff --git a/RPC/lib/array_list.cc b/RPC/lib/array_list.cc
new file mode 100644
index 0000000..bda77e9
--- /dev/null
+++ b/RPC/lib/array_list.cc
@@ -0,0 +1,21 @@
+#include "array_list.h"
+#include "mma_client.h"
+
+namespace proj4 {
+    ArrayList::ArrayList(size_t sz, MmaClient* cur_mma, int id){
+        this -> mma_client = cur_mma;
+        this -> array_id = id;
+        this -> size = sz;
+
+    }
+    int ArrayList::Read (unsigned long idx){
+        //read the value in the virtual index of 'idx' from mma's memory space
+        return mma_client -> ReadPage(this -> array_id, idx / PageSize, idx % PageSize);
+    }
+    void ArrayList::Write (unsigned long idx, int value){
+        //write 'value' in the virtual index of 'idx' into mma's memory space
+        mma_client -> WritePage(this -> array_id, idx/PageSize, idx % PageSize, value);
+    }
+    ArrayList::~ArrayList(){
+    }
+} // namespace: proj4
\ No newline at end of file
diff --git a/RPC/lib/array_list.h b/RPC/lib/array_list.h
new file mode 100644
index 0000000..b48ee5b
--- /dev/null
+++ b/RPC/lib/array_list.h
@@ -0,0 +1,27 @@
+#ifndef ARRAY_LIST_H
+#define ARRAY_LIST_H
+
+#include <cstdlib>
+
+#define PageSize 1024
+
+namespace proj4 {
+
+    class MmaClient;
+
+    class ArrayList{
+        private:
+        friend class MmaClient;
+        size_t size;
+        MmaClient* mma_client;
+        int array_id;
+        ArrayList(size_t, MmaClient*, int);
+        ~ArrayList();
+        public:
+        // you should not modify the public interfaces used in tests
+        int Read (unsigned long);
+        void Write (unsigned long, int);
+    };
+
+} // namespce: proj4
+#endif
\ No newline at end of file
diff --git a/RPC/lib/memory_manager.cc b/RPC/lib/memory_manager.cc
new file mode 100644
index 0000000..c365eb2
--- /dev/null
+++ b/RPC/lib/memory_manager.cc
@@ -0,0 +1,373 @@
+#include <string.h>
+
+#include "memory_manager.h"
+
+namespace proj4 {
+    PageFrame::PageFrame(){
+    }
+
+    int& PageFrame::operator[] (unsigned long idx){
+        //each page should provide random access like an array
+        return mem[idx];
+    }
+
+    void PageFrame::WriteDisk(std::string filename) {    
+        FILE* f = fopen(filename.c_str(), "wb");
+        if(f == nullptr){
+            throw std::runtime_error("error openning file "+filename+"!");
+        } else {
+            fwrite(mem, sizeof(int), PageSize, f);
+            fclose(f);
+        }
+    }
+
+    void PageFrame::ReadDisk(std::string filename) {
+        FILE* f = fopen(filename.c_str(),"rb");
+        if (f == nullptr) {
+            memset(mem,0,sizeof(int)*PageSize);
+            f = fopen(filename.c_str(),"wb");
+            fwrite(mem, sizeof(int), PageSize, f);
+            fclose(f);
+        } else {
+            fread(mem, sizeof(int), PageSize, f);
+            fclose(f);
+        }        
+    }
+    
+    PageInfo::PageInfo(){
+        holder = -1;
+        virtual_page_id = -1;
+    }
+
+    void PageInfo::SetInfo(int cur_holder, int cur_vid){
+        //modify the page states
+        //you can add extra parameters if needed
+        holder = cur_holder;
+        virtual_page_id = cur_vid;
+    }
+
+    void PageInfo::ClearInfo(){
+        //clear the page states
+        //you can add extra parameters if needed
+        holder = -1;
+        virtual_page_id = -1;
+    }
+
+    int PageInfo::GetHolder(){return holder;}
+    int PageInfo::GetVid(){return virtual_page_id;}
+
+    MemoryManager::MemoryManager(size_t sz, ReplacementPolicy Policy){
+        mma_sz = sz;
+        mem = new PageFrame[sz];
+        page_info = new PageInfo[sz];
+        free = new bool[sz];
+        used = new bool[sz];
+        modified = new bool[sz];
+        for (int i = 0 ; i < int(sz); i ++){
+            free[i] = true;
+            used[i] = false;
+            modified[i] = false;
+        }
+        policy = Policy;
+    }
+
+    MemoryManager::~MemoryManager(){  
+        for (auto it = filename_exist.cbegin(); it != filename_exist.cend(); ++it) {
+            if ((*it).second)
+                remove(((*it).first).c_str());
+        }
+        delete free;
+        delete used;
+        delete modified;
+        delete mem;
+        delete page_info;
+    }
+
+    void MemoryManager::PageOut(int physical_page_id, std::string filename) {
+        mem[physical_page_id].WriteDisk(filename);
+        filename_exist[filename] = true;
+    }
+
+    void MemoryManager::PageIn(int array_id, int virtual_page_id, int physical_page_id){
+        std::string name = file_name(array_id, virtual_page_id);
+        mem[physical_page_id].ReadDisk(name);
+        filename_exist[name] = true;
+    }
+
+    int MemoryManager::PageReplace(int array_id, int virtual_page_id, bool is_write,  std::string& output_filename){
+        //implement your page replacement policy here
+        //try to find a free page
+        int i;
+        for ( i = 0 ; i < int(mma_sz) ; i ++ ) {
+            if (free[i]) break;
+        }
+        if ( i < int(mma_sz)) {
+            //A free page found
+            page_map[array_id][virtual_page_id] = i;
+            free[i] = false;
+            used[i] = true;
+            modified[i] = is_write;
+            page_info[i].SetInfo(array_id, virtual_page_id);
+            //////////////////////////////////
+            int times_to_wait = 0;
+            resource_queue[page_name(i)].push(array_id);
+            if (resource_queue[page_name(i)].size() > 1) {
+                times_to_wait ++;
+            }
+            resource_queue[file_name(array_id, virtual_page_id)].push(array_id);
+            if (resource_queue[file_name(array_id, virtual_page_id)].size() > 1){
+                times_to_wait ++;
+            }
+            data_lock.unlock();
+            for (int j = 0; j < times_to_wait; j ++) {
+                sp[array_id].P();
+            }
+            //////////////////////////////////
+            PageIn(array_id, virtual_page_id, i);
+            return i;
+        } else {
+            if (policy == CLOCK) {
+                //clock algorithm
+                while(true) {
+                    if (used[clock_head]) {
+                        used[clock_head] = false;
+                        clock_head = (clock_head + 1) % int (mma_sz);
+                    } else {
+                        break;
+                    }
+                }
+            }
+            int pid = clock_head;
+            clock_head = (clock_head + 1) % int(mma_sz);
+            //update page_map
+            int old_holder = page_info[pid].GetHolder();
+            int old_vid = page_info[pid].GetVid();
+            //page_map[old_holder][old_vid] = -1;//Page table cleared
+            bool dirty = modified[pid];
+            page_info[pid].SetInfo(array_id, virtual_page_id);
+            page_map[array_id][virtual_page_id] = pid;
+            page_map[old_holder][old_vid] = -1;
+            free[pid] = false;
+            used[pid] = true;
+            modified[pid] = is_write;
+            if(dirty)output_filename = file_name(old_holder, old_vid);
+            //////////////////////////////////
+            int times_to_wait = 0;
+            resource_queue[page_name(pid)].push(array_id);
+            if (resource_queue[page_name(pid)].size() > 1){
+                times_to_wait ++;
+            }
+            resource_queue[file_name(array_id, virtual_page_id)].push(array_id);
+            if (resource_queue[file_name(array_id, virtual_page_id)].size() > 1){
+                times_to_wait ++;
+            }
+            if (dirty) {
+                resource_queue[output_filename].push(array_id);
+                if (resource_queue[output_filename].size() > 1) {
+                    times_to_wait ++;
+                }
+            }
+            data_lock.unlock();
+            for (int j = 0; j < times_to_wait; j ++) {
+                sp[array_id].P();
+            }
+            //////////////////////////////////
+            if(dirty)PageOut(pid, output_filename);
+            PageIn(array_id, virtual_page_id, pid);
+            return pid;
+        }
+
+    }
+
+    int MemoryManager::ReadPage(int array_id, int virtual_page_id, int offset){
+        // for arrayList of 'array_id', return the target value on its virtual space
+        //////////////////////////////////
+        data_lock.lock();
+        //////////////////////////////////
+        bool in_memory = true;
+        if (page_map.count(array_id) == 0) {
+            //the arraylist is first used
+            page_map[array_id] = std::map<int, int>();
+            in_memory = false;
+        } else if (page_map[array_id].count(virtual_page_id) == 0){
+            in_memory = false;
+            //virtual page is first used
+            if (int(page_map[array_id].size()) == num_max_pages[array_id]) {
+                data_lock.unlock();
+                throw std::runtime_error("Array List " + std::to_string(array_id)+" exceeds the allocated space!");
+            }
+        } else if (page_map[array_id][virtual_page_id] == -1) {
+            in_memory = false;
+        }
+        if (in_memory) {
+            int pid = page_map[array_id][virtual_page_id];
+            used[pid] = true;
+            //////////////////////////////////
+            resource_queue[page_name(pid)].push(array_id);
+            int queue_size = resource_queue[page_name(pid)].size();
+            data_lock.unlock();
+            if (queue_size > 1) {
+                sp[array_id].P();
+            }
+            //////////////////////////////////
+            int result = (mem[pid])[offset];
+            //////////////////////////////////
+            data_lock.lock();
+            resource_queue[page_name(pid)].pop();
+            if (resource_queue[page_name(pid)].size() > 0) {
+                sp[resource_queue[page_name(pid)].front()].V();
+            }
+            data_lock.unlock();
+            //////////////////////////////////
+            return result; 
+        } else {
+            std::string input_filename = file_name(array_id, virtual_page_id);
+            std::string output_filename;
+
+            int pid = PageReplace(array_id, virtual_page_id, false, output_filename);
+            
+            int result = (mem[pid])[offset];
+            //////////////////////////////////
+            data_lock.lock();
+            resource_queue[page_name(pid)].pop();
+            if (resource_queue[page_name(pid)].size() > 0) {
+                sp[resource_queue[page_name(pid)].front()].V();
+            }
+            resource_queue[input_filename].pop();
+            if (resource_queue[input_filename].size() > 0) {
+                sp[resource_queue[input_filename].front()].V();
+            }
+
+            if (output_filename.size() > 0) {
+                resource_queue[output_filename].pop();
+                if (resource_queue[output_filename].size() > 0) {
+                    sp[resource_queue[output_filename].front()].V();
+                }
+            }
+            data_lock.unlock();
+            //////////////////////////////////
+            return result; 
+        }
+    }
+
+    void MemoryManager::WritePage(int array_id, int virtual_page_id, int offset, int value){
+        // for arrayList of 'array_id', write 'value' into the target position on its virtual space
+        //////////////////////////////////
+        data_lock.lock();
+        //////////////////////////////////
+        
+        bool in_memory = true;
+        if (page_map.count(array_id) == 0) {
+            //the arraylist is first used
+            page_map[array_id] = std::map<int, int>();
+            in_memory = false;
+        } else if (page_map[array_id].count(virtual_page_id) == 0){
+            //virtual page is first used
+            in_memory = false;
+            if (int(page_map[array_id].size()) == num_max_pages[array_id]) {
+                data_lock.unlock();
+                throw std::runtime_error("Array List " + std::to_string(array_id)+" exceeds the allocated space!");
+            } 
+        } else if (page_map[array_id][virtual_page_id] == -1) {
+            in_memory = false;
+        }
+        
+        if (in_memory) {
+            int pid = page_map[array_id][virtual_page_id];
+            used[pid] = true;
+            modified[pid] = true;
+            
+            //////////////////////////////////
+            resource_queue[page_name(pid)].push(array_id);
+            int queue_size = resource_queue[page_name(pid)].size();
+            data_lock.unlock();
+            if (queue_size > 1) {
+                sp[array_id].P();
+            }
+            //////////////////////////////////
+
+            (mem[pid])[offset] = value;
+
+            //////////////////////////////////
+            data_lock.lock();
+            resource_queue[page_name(pid)].pop();
+            if (resource_queue[page_name(pid)].size() > 0) {
+                sp[resource_queue[page_name(pid)].front()].V();
+            }
+            data_lock.unlock();
+            //////////////////////////////////
+            
+            return; 
+        } else {
+            std::string input_filename = file_name(array_id, virtual_page_id);
+            std::string output_filename ;
+            int pid = PageReplace(array_id, virtual_page_id, true, output_filename);//datalock -> pagelock
+            (mem[pid])[offset] = value;
+            //////////////////////////////////
+            data_lock.lock();
+            resource_queue[page_name(pid)].pop();
+            if (resource_queue[page_name(pid)].size() > 0) {
+                sp[resource_queue[page_name(pid)].front()].V();
+            }
+            resource_queue[input_filename].pop();
+            if (resource_queue[input_filename].size() > 0) {
+                sp[resource_queue[input_filename].front()].V();
+            }
+
+            if (output_filename.size() > 0) {
+                resource_queue[output_filename].pop();
+                if (resource_queue[output_filename].size() > 0) {
+                    sp[resource_queue[output_filename].front()].V();
+                }
+            }
+            data_lock.unlock();
+            //////////////////////////////////
+            return;
+        }
+    }
+
+    int MemoryManager::Allocate(size_t sz){
+        // when an application requires for memory, 
+        //create an ArrayList and record mappings
+        //from its virtual memory space to the physical memory space
+        data_lock.lock();
+
+        num_max_pages[next_array_id] = (int(sz) + int(PageSize) - 1)/int(PageSize);
+        int array_id = next_array_id;
+        next_array_id ++;
+
+        data_lock.unlock();
+        return array_id;
+    }
+    size_t MemoryManager::Release(int array_id){
+        // an application will call release() function when destroying its arrayList
+        // release the virtual space of the arrayList and erase the corresponding mappings
+
+        data_lock.lock();
+        std::map<int, int>::iterator it = page_map[array_id].begin();
+        for (; it != page_map[array_id].end(); ++ it) {
+            int vid = it -> first;
+            int pid = it -> second;
+            std::string name = file_name(array_id, vid);
+            remove(name.c_str());
+            filename_exist[name] = false;
+            if (pid != -1) {
+                free[pid] = true;
+                used[pid] = false;
+                modified[pid] = false;
+                page_info[pid].ClearInfo();
+            }
+        }
+        data_lock.unlock();
+        return num_max_pages[array_id];
+    }
+
+    std::string file_name(int holder, int vid) {
+        return "f" + std::to_string(holder) +'_'+std::to_string(vid);
+    }
+
+    std::string page_name(int pid) {
+        return "p" + std::to_string(pid);
+    }
+
+} // namespace: proj4
diff --git a/RPC/lib/memory_manager.h b/RPC/lib/memory_manager.h
new file mode 100644
index 0000000..b257043
--- /dev/null
+++ b/RPC/lib/memory_manager.h
@@ -0,0 +1,90 @@
+#ifndef MEMORY_MANAGER_H_
+#define MEMORY_MANAGER_H_
+#include <map>
+#include <queue>
+#include <string>
+#include <vector>
+#include <mutex>
+#include "semaphore.h"
+
+#define PageSize 1024
+
+namespace proj4 {
+
+class PageFrame {
+public:
+    PageFrame();
+    int& operator[] (unsigned long);
+    void WriteDisk(std::string);
+    void ReadDisk(std::string);
+private:
+    int mem[PageSize];
+};
+
+class PageInfo {
+public:
+    PageInfo();
+    void SetInfo(int,int);
+    void ClearInfo();
+    int GetHolder();
+    int GetVid();
+private:
+    int holder; //page holder id (array_id)
+    int virtual_page_id; // page virtual #
+    /*add your extra states here freely for implementation*/
+};
+
+enum ReplacementPolicy{
+    FIFO = 0,
+    CLOCK
+};
+
+class MemoryManager {
+public:
+    // you should not modify the public interfaces used in tests
+    MemoryManager(size_t, ReplacementPolicy Policy = CLOCK);
+    int ReadPage(int array_id, int virtual_page_id, int offset);
+    void WritePage(int array_id, int virtual_page_id, int offset, int value);
+    int Allocate(size_t);
+    size_t Release(int array_id);
+    ~MemoryManager();
+
+private:
+    std::map<std::string, int*> disk;
+    std::map<int, std::map<int, int>> page_map;
+    // mapping from ArrayList's virtual page # to physical page #
+    PageFrame* mem; // physical pages, using 'PageFrame* mem' is also acceptable 
+    PageInfo* page_info; // physical page info
+    int next_array_id = 0;
+    size_t mma_sz;
+    void PageIn(int array_id, int virtual_page_id, int physical_page_id);
+    void PageOut(int physical_page_id, std::string filename);
+    int PageReplace(int array_id, int virtual_page_id, bool is_write, std::string& output_filename);
+
+    //states of the memory
+    bool* free;
+    bool* used;
+    bool* modified;
+
+    bool test_mode = false;
+    ReplacementPolicy policy;
+    int clock_head = 0;
+    //states of the array_list
+    std::map<int, int> num_max_pages;
+    //array_id -> number of available pages
+    //extra functions
+    std::map<std::string, bool> filename_exist;
+
+    //Manage the queues
+    std::map<std::string, std::queue<int>> resource_queue;
+    std::map<int, Semaphore> sp;
+    std::mutex data_lock;//guards the metadata
+};
+
+std::string file_name(int,int);
+std::string page_name(int);
+
+}  // namespce: proj4
+
+#endif
+
diff --git a/RPC/lib/mma_client.cc b/RPC/lib/mma_client.cc
new file mode 100644
index 0000000..9f39a29
--- /dev/null
+++ b/RPC/lib/mma_client.cc
@@ -0,0 +1,60 @@
+#include "mma_client.h"
+#include "array_list.h"
+#include <thread>
+
+namespace proj4 {
+
+    ArrayList* MmaClient::Allocate(size_t sz) {
+
+        while (true) {
+            ClientContext context;
+            AllocateRequest request;
+            AllocateReply reply;
+            request.set_size(sz);
+            Status status = stub_->Allocate(&context, request, &reply);
+
+            if (status.ok()) {
+                return new ArrayList(sz, this, reply.array_id());
+            } else {
+                // wait untill allocation succeed
+                std::this_thread::sleep_for(std::chrono::milliseconds(500));
+            }
+        }
+    }
+
+    void MmaClient::Free(ArrayList* arr) {
+        ClientContext context;
+        ReleaseRequest request;
+        ReleaseReply reply;
+        request.set_array_id(arr->array_id);
+
+        Status status = stub_->Release(&context, request, &reply);
+        delete arr;
+    };
+
+    int MmaClient::ReadPage(int array_id, int virtual_page_id, int offset) {
+        ClientContext context;
+        ReadPageRequest request;
+        ReadPageReply reply;
+        request.set_array_id(array_id);
+        request.set_virtual_page_id(virtual_page_id);
+        request.set_offset(offset);
+
+        Status status = stub_->ReadPage(&context, request, &reply);
+
+        return reply.value();
+    }
+
+    void MmaClient::WritePage(int array_id, int virtual_page_id, int offset, int value) {
+        ClientContext context;
+        WritePageRequest request;
+        WritePageReply reply;
+        request.set_array_id(array_id);
+        request.set_virtual_page_id(virtual_page_id);
+        request.set_offset(offset);
+        request.set_value(value);
+
+        Status status = stub_->WritePage(&context, request, &reply);
+    }
+
+} //namespace proj4
diff --git a/RPC/lib/mma_client.h b/RPC/lib/mma_client.h
new file mode 100644
index 0000000..e6b7dd7
--- /dev/null
+++ b/RPC/lib/mma_client.h
@@ -0,0 +1,47 @@
+#ifndef MMA_CLIENT_H
+#define MMA_CLIENT_H
+
+#include <memory>
+#include <cstdlib>
+
+#include <grpc++/grpc++.h>
+
+#ifdef BAZEL_BUILD
+#include "proto/mma.grpc.pb.h"
+#else
+#include "mma.grpc.pb.h"
+#endif
+
+using grpc::Channel;
+using grpc::ClientContext;
+using grpc::Status;
+using mma::MMAService;
+using mma::AllocateRequest;
+using mma::AllocateReply;
+using mma::ReleaseRequest;
+using mma::ReleaseReply;
+using mma::ReadPageRequest;
+using mma::ReadPageReply;
+using mma::WritePageRequest;
+using mma::WritePageReply;
+
+
+namespace proj4 {
+
+class ArrayList;
+
+class MmaClient {
+public:
+    MmaClient(std::shared_ptr<Channel> channel) : stub_(MMAService::NewStub(channel)) {}
+    ArrayList* Allocate(size_t);
+    void Free(ArrayList*);
+    int ReadPage(int array_id, int virtual_page_id, int offset);
+    void WritePage(int array_id, int virtual_page_id, int offset, int value);
+
+private:
+  std::unique_ptr<MMAService::Stub> stub_;
+};
+
+} //namespace proj4
+
+#endif
\ No newline at end of file
diff --git a/RPC/lib/mma_server.cc b/RPC/lib/mma_server.cc
new file mode 100644
index 0000000..2a4632f
--- /dev/null
+++ b/RPC/lib/mma_server.cc
@@ -0,0 +1,66 @@
+#include "mma_server.h"
+
+namespace proj4 {
+
+    Status MmaServer::Allocate (ServerContext* context, const AllocateRequest* request, AllocateReply* reply) {
+        size_t page_request = (int(request->size()) + int(PageSize) - 1) / int(PageSize);
+        this->server_lock.lock();
+        if ((this->max_vir_page_num <= this->total_vir_page_num+page_request) && (this->max_vir_page_num != 0)) {
+            this->server_lock.unlock();
+            return Status::CANCELLED;
+        }
+        else {
+            total_vir_page_num += page_request;
+            this->server_lock.unlock();
+            int array_id = mma->Allocate(request->size());
+            reply->set_array_id(array_id);
+            return Status::OK;
+        }
+    }
+
+    Status MmaServer::Release (ServerContext* context, const ReleaseRequest*   request, ReleaseReply* reply) {
+        size_t page_used = mma->Release(request->array_id());
+        this->server_lock.lock();
+        total_vir_page_num -= page_used;
+        this->server_lock.unlock();
+        return Status::OK;
+    }
+
+    Status MmaServer::ReadPage (ServerContext* context, const ReadPageRequest*  request, ReadPageReply* reply) {
+        int value = mma->ReadPage(request->array_id(), request->virtual_page_id(), request->offset());
+        reply->set_value(value);
+        return Status::OK;
+    }
+
+    Status MmaServer::WritePage(ServerContext* context, const WritePageRequest* request, WritePageReply* reply) {
+        mma->WritePage(request->array_id(), request->virtual_page_id(), request->offset(), request->value());
+        return Status::OK;
+    }
+
+    // Declare the server itself here
+    std::unique_ptr<Server> mma_server;
+
+    void RunServerL(size_t phy_page_num, size_t max_vir_page_num) {
+        std::string server_address("0.0.0.0:50051");
+        MmaServer service(phy_page_num, max_vir_page_num);
+
+        grpc::EnableDefaultHealthCheckService(true);
+        grpc::reflection::InitProtoReflectionServerBuilderPlugin();
+        ServerBuilder builder;
+        builder.AddListeningPort(server_address, grpc::InsecureServerCredentials());
+        builder.RegisterService(&service);
+        mma_server = std::unique_ptr<Server> (builder.BuildAndStart());
+        // std::cout << "Server listening on " << server_address << std::endl;
+        mma_server->Wait();
+    }
+
+    void RunServerUL(size_t phy_page_num) {
+        RunServerL(phy_page_num, 0);
+    }
+
+    void ShutdownServer() {
+        // std::cout << "Server shutdown " << std::endl;
+        mma_server->Shutdown();
+    }
+
+} //namespace proj4
\ No newline at end of file
diff --git a/RPC/lib/mma_server.h b/RPC/lib/mma_server.h
new file mode 100644
index 0000000..25cce04
--- /dev/null
+++ b/RPC/lib/mma_server.h
@@ -0,0 +1,74 @@
+#ifndef MMA_SERVER_H
+#define MMA_SERVER_H
+
+#include <iostream>
+#include <memory>
+#include <string>
+#include <cstdlib>
+#include <mutex>
+
+#include <grpc++/grpc++.h>
+#include <grpc++/ext/proto_server_reflection_plugin.h>
+#include <grpc++/health_check_service_interface.h>
+
+#ifdef BAZEL_BUILD
+#include "proto/mma.grpc.pb.h"
+#else
+#include "mma.grpc.pb.h"
+#endif
+
+#include "memory_manager.h"
+
+using grpc::Server;
+using grpc::ServerBuilder;
+using grpc::ServerContext;
+using grpc::Status;
+using mma::MMAService;
+using mma::AllocateRequest;
+using mma::AllocateReply;
+using mma::ReleaseRequest;
+using mma::ReleaseReply;
+using mma::ReadPageRequest;
+using mma::ReadPageReply;
+using mma::WritePageRequest;
+using mma::WritePageReply;
+
+
+
+// Logic and data behind the server's behavior.
+
+namespace proj4 {
+
+class MmaServer final : public MMAService::Service {
+public:
+    //MmaServer(size_t phy_page_num) : mma(new MemoryManager(phy_page_num){}
+    MmaServer(size_t phy_page_num, size_t max_vir_page_num) {
+        this->mma = new MemoryManager(phy_page_num);
+        this->max_vir_page_num = max_vir_page_num;
+    }
+    ~MmaServer() {delete this->mma;}
+
+    Status Allocate (ServerContext* context, const AllocateRequest*  request, AllocateReply*  reply) override;
+    Status Release  (ServerContext* context, const ReleaseRequest*   request, ReleaseReply*   reply) override;
+    Status ReadPage (ServerContext* context, const ReadPageRequest*  request, ReadPageReply*  reply) override;
+    Status WritePage(ServerContext* context, const WritePageRequest* request, WritePageReply* reply) override;
+
+private:
+    MemoryManager* mma;
+    size_t max_vir_page_num = 0;
+    size_t total_vir_page_num = 0;
+    std::mutex server_lock;
+};
+
+// setup a server with UnLimited virtual memory space
+void RunServerUL(size_t phy_page_num);
+
+// setup a server with Limited virtual memory space
+void RunServerL(size_t phy_page_num, size_t max_vir_page_num);
+
+// shutdown the server setup by RunServerUL or RunServerL
+void ShutdownServer();
+
+} //namespace proj4
+
+#endif
\ No newline at end of file
diff --git a/RPC/lib/semaphore.cc b/RPC/lib/semaphore.cc
new file mode 100644
index 0000000..832c505
--- /dev/null
+++ b/RPC/lib/semaphore.cc
@@ -0,0 +1,18 @@
+#include "semaphore.h"
+
+namespace proj4 {
+    void Semaphore::P() {
+        std::unique_lock<std::mutex> loc(m);
+        if (--count < 0) {
+            cv.wait(loc);
+        }
+    }
+
+    void Semaphore::V() {
+        std::unique_lock<std::mutex> loc(m);
+        if (++count <= 0) {
+            cv.notify_one();
+        }
+    }
+
+}//proj4
\ No newline at end of file
diff --git a/RPC/lib/semaphore.h b/RPC/lib/semaphore.h
new file mode 100644
index 0000000..fdfda67
--- /dev/null
+++ b/RPC/lib/semaphore.h
@@ -0,0 +1,19 @@
+#ifndef SEMAPHORE_H_
+#define SEMAPHORE_H_
+#include <condition_variable>
+#include <mutex>
+
+namespace proj4 {
+class Semaphore{
+private:
+    int count;
+    std::mutex m;
+    std::condition_variable cv;
+public:
+    Semaphore(int init = 0):count(init){}
+    void P();
+    void V();	
+};
+}//proj4
+
+#endif // SEMAPHORE_H_
diff --git a/RPC/lib/utils.cc b/RPC/lib/utils.cc
new file mode 100644
index 0000000..867cdd7
--- /dev/null
+++ b/RPC/lib/utils.cc
@@ -0,0 +1,24 @@
+#include <chrono>
+#include <thread>
+#include <cstdlib>
+#include <iostream>
+#include "utils.h"
+
+namespace proj4 {
+
+void a_slow_function(int seconds) {
+    std::this_thread::sleep_for(std::chrono::seconds(seconds));
+}
+
+AutoTimer::AutoTimer(std::string name): 
+        m_name(std::move(name)),
+        m_beg(std::chrono::high_resolution_clock::now()) { 
+    }
+
+AutoTimer::~AutoTimer() {
+    auto end = std::chrono::high_resolution_clock::now();
+    auto dur = std::chrono::duration_cast<std::chrono::microseconds>(end - m_beg);
+    std::cout << m_name << " : " << dur.count() << " usec\n";
+}
+
+} // namespce: proj4
diff --git a/RPC/lib/utils.h b/RPC/lib/utils.h
new file mode 100644
index 0000000..ae33129
--- /dev/null
+++ b/RPC/lib/utils.h
@@ -0,0 +1,21 @@
+#ifndef DEADLOCK_LIB_UTILS_H_
+#define DEADLOCK_LIB_UTILS_H_
+
+#include <chrono>
+
+namespace proj4 {
+
+void a_slow_function(int seconds);
+
+class AutoTimer {
+ public:
+  AutoTimer(std::string name);
+  ~AutoTimer(); 
+ private:
+  std::string m_name;
+  std::chrono::time_point<std::chrono::high_resolution_clock> m_beg;
+};
+
+}  // namespce: proj4
+
+#endif
\ No newline at end of file
diff --git a/RPC/mma_test.cc b/RPC/mma_test.cc
new file mode 100644
index 0000000..e47e650
--- /dev/null
+++ b/RPC/mma_test.cc
@@ -0,0 +1,171 @@
+#include <gtest/gtest.h>
+#include<vector>
+#include<thread>
+#include<string>
+
+#include "lib/array_list.h"
+#include "lib/mma_client.h"
+#include "lib/mma_server.h"
+
+namespace proj4 {
+namespace testing{
+
+class MMATestA : public ::testing::Test {
+ protected:
+  void SetUp() override {
+    server_thread = new std::thread(&RunServerUL, 10);
+    server_thread->detach();
+    sleep(1);
+
+    std::string target_str = "localhost:50051";
+    mma = new MmaClient(
+        grpc::CreateChannel(target_str, grpc::InsecureChannelCredentials()));
+
+    workload_sz_1 = 4000; 
+    workload_sz_2 = 2000; 
+    workload_sz_3 = 100; 
+    workload_sz_4 = 2000;
+    metrix_length = 10;
+    loop_times = 10;
+    thread_num = 20;
+  }
+  void TearDown() override {ShutdownServer(); delete mma;}
+    size_t workload_sz_1;
+    size_t workload_sz_2;
+    size_t workload_sz_3;
+    size_t workload_sz_4;
+    int metrix_length;
+    int loop_times;
+    int thread_num;
+    MmaClient* mma;
+    std::thread* server_thread;
+    std::vector<std::vector<int>>metrix = {{ 2850, 2895, 2940, 2985, 3030, 3075, 3120, 3165, 3210, 3255 },
+    { 7350, 7495, 7640, 7785, 7930, 8075, 8220, 8365, 8510, 8655 },
+    { 11850, 12095, 12340, 12585, 12830, 13075, 13320, 13565, 13810, 14055 },
+    { 16350, 16695, 17040, 17385, 17730, 18075, 18420, 18765, 19110, 19455 },
+    { 20850, 21295, 21740, 22185, 22630, 23075, 23520, 23965, 24410, 24855 },
+    { 25350, 25895, 26440, 26985, 27530, 28075, 28620, 29165, 29710, 30255 },
+    { 29850, 30495, 31140, 31785, 32430, 33075, 33720, 34365, 35010, 35655 },
+    { 34350, 35095, 35840, 36585, 37330, 38075, 38820, 39565, 40310, 41055 },
+    { 38850, 39695, 40540, 41385, 42230, 43075, 43920, 44765, 45610, 46455 },
+    { 43350, 44295, 45240, 46185, 47130, 48075, 49020, 49965, 50910, 51855 },};
+};
+
+class MMATestB : public ::testing::Test {
+ protected:
+  void SetUp() override {
+    server_thread = new std::thread(&RunServerL, 10, 20);
+    server_thread->detach();
+    sleep(1);
+
+    std::string target_str = "localhost:50051";
+    mma = new MmaClient(
+        grpc::CreateChannel(target_str, grpc::InsecureChannelCredentials()));
+
+    workload_sz = 2000;
+    thread_num = 20;
+  }
+  void TearDown() override {ShutdownServer(); delete mma;}
+    size_t workload_sz;
+    int thread_num;
+    MmaClient* mma;
+    std::thread* server_thread;
+};
+
+TEST_F(MMATestA,task1){
+	ArrayList* arr = mma->Allocate(workload_sz_1);
+    for(unsigned long i = 0; i<workload_sz_1; i++){
+        arr->Write(i, 1);
+    }
+    for(unsigned long i = 0; i<workload_sz_1; i++){
+        EXPECT_EQ(1, arr->Read(i));
+    }
+    mma->Free(arr);
+}
+
+TEST_F(MMATestA,task2){
+	std::vector<ArrayList*>arr;
+    for(int i = 0; i<loop_times; i++){
+        arr.push_back(mma->Allocate(workload_sz_2));
+        for(unsigned long j = 0; j < workload_sz_2; j++)arr[i]->Write(j, i);
+    }
+    for(int i = 0; i<loop_times; i++){
+        if(i %2)mma->Free(arr[i]);
+        else for(unsigned long j = 0; j < workload_sz_2; j++)EXPECT_EQ(i, arr[i]->Read(j));
+    }
+    for(int i = 0; i<loop_times; i++){
+        if(i %2 == 0)mma->Free(arr[i]);
+    }
+}
+
+TEST_F(MMATestA,task3){
+	std::vector<ArrayList*>metrixA, metrixB, metrixC;
+    for(int i = 0; i<metrix_length; i++){
+        metrixA.push_back(mma->Allocate(metrix_length));
+        metrixB.push_back(mma->Allocate(metrix_length));
+        metrixC.push_back(mma->Allocate(metrix_length));
+        for(int j = 0; j < metrix_length; j++){
+            metrixA[i]->Write(j, i*metrix_length+j);
+            metrixB[i]->Write(j, i*metrix_length+j);
+            metrixC[i]->Write(j, 0);
+        }
+    }
+    
+    for(int i = 0; i<metrix_length; i++){
+        for(int j = 0; j<metrix_length; j++){
+            for(int k = 0; k < metrix_length; k++){
+                metrixC[i]->Write(j, metrixC[i]->Read(j)+metrixA[i]->Read(k)*metrixB[k]->Read(j));
+            }
+        }
+    }
+
+    for(int i = 0; i<metrix_length; i++){
+        for(int j = 0; j<metrix_length; j++){
+            EXPECT_EQ(metrix[i][j], metrixC[i]->Read(j));
+        }
+    }
+
+    for(int i = 0; i<metrix_length; i++){
+        mma->Free(metrixA[i]);
+        mma->Free(metrixB[i]);
+        mma->Free(metrixC[i]);
+    }
+
+}
+
+void workload(MmaClient * my_mma, size_t workload_sz){
+    ArrayList* arr = my_mma->Allocate(workload_sz);
+    for(unsigned long j = 0; j < workload_sz; j++)arr->Write(j, j);
+    for(unsigned long j = 0; j < workload_sz; j++)EXPECT_EQ(j, arr->Read(j));
+    my_mma->Free(arr);
+}
+
+TEST_F(MMATestA,task4){
+    std::vector<std::thread*> pool;
+    for(int i = 0; i<thread_num; i++) {
+        pool.push_back(new std::thread(&workload, mma, workload_sz_4));
+    }
+
+    for (auto t: pool) {
+        t->join();
+    }
+}
+
+TEST_F(MMATestB,task5){
+    std::vector<std::thread*> pool;
+    for(int i = 0; i<thread_num; i++) {
+        pool.push_back(new std::thread(&workload, mma, workload_sz));
+    }
+
+    for (auto t: pool) {
+        t->join();
+    }
+}
+
+} // namespace testing
+} // namespace proj4
+
+int main(int argc,char **argv){
+  testing::InitGoogleTest(&argc,argv);
+  return RUN_ALL_TESTS();
+}
diff --git a/RPC/proto/BUILD b/RPC/proto/BUILD
new file mode 100644
index 0000000..4df9ffb
--- /dev/null
+++ b/RPC/proto/BUILD
@@ -0,0 +1,23 @@
+package(default_visibility = ["//visibility:public"])
+
+load("@rules_proto//proto:defs.bzl", "proto_library")
+load("@com_github_grpc_grpc//bazel:cc_grpc_library.bzl", "cc_grpc_library")
+
+
+
+cc_grpc_library(
+    name = "mma_grpc",
+    srcs = [":mma_proto"],
+    grpc_only = True,
+    deps = [":mma_cc_proto"],
+)
+ 
+cc_proto_library(
+    name = "mma_cc_proto",
+    deps = [":mma_proto"],
+)
+ 
+proto_library(
+    name = "mma_proto",
+	srcs = ["mma.proto"],
+)
\ No newline at end of file
diff --git a/RPC/proto/mma.proto b/RPC/proto/mma.proto
new file mode 100644
index 0000000..75c91e0
--- /dev/null
+++ b/RPC/proto/mma.proto
@@ -0,0 +1,57 @@
+syntax = "proto3";
+
+option objc_class_prefix = "MMA";
+
+package mma;
+
+// define your service here
+
+service MMAService {
+    rpc Allocate (AllocateRequest) returns (AllocateReply)  {}
+    rpc Release  (ReleaseRequest)  returns (ReleaseReply)   {}
+    rpc ReadPage (ReadPageRequest) returns (ReadPageReply)  {}
+    rpc WritePage(WritePageRequest)returns (WritePageReply) {}
+}
+
+message AllocateRequest {
+    // args here please
+    int32 size = 1;
+}
+
+message AllocateReply {
+    // args here please
+    int32 array_id = 1;
+}
+
+message ReleaseRequest {
+    // args here please
+    int32 array_id = 1;
+}
+
+message ReleaseReply {
+    // args here please
+}
+
+message ReadPageRequest {
+    // args here please
+    int32 array_id = 1;
+    int32 virtual_page_id = 2;
+    int32 offset = 3;
+}
+
+message ReadPageReply {
+    // args here please
+    int32 value = 1;
+}
+
+message WritePageRequest {
+    // args here please
+    int32 array_id = 1;
+    int32 virtual_page_id = 2;
+    int32 offset = 3;
+    int32 value = 4;
+}
+
+message WritePageReply {
+    // args here please
+}
\ No newline at end of file
diff --git a/Thread-1/.bazeliskrc b/Thread-1/.bazeliskrc
index f81d3f7..2159662 100644
--- a/Thread-1/.bazeliskrc
+++ b/Thread-1/.bazeliskrc
@@ -1 +1 @@
-USE_BAZEL_VERSION=4.2.1
+USE_BAZEL_VERSION=4.2.1
diff --git a/Thread-1/BUILD b/Thread-1/BUILD
index 28f4114..e85a3fa 100644
--- a/Thread-1/BUILD
+++ b/Thread-1/BUILD
@@ -9,12 +9,14 @@ cc_binary(
         "//lib:embedding_lib",
         "//lib:instruction_lib",
         "//lib:utils_lib",
-        "//lib:model_lib"
+        "//lib:model_lib",
+        "//scheduler:scheduler"
     ],
     copts = [
         "-std=c++11",
     ],
     data = glob(["data/q0*"]),
+    
 )
 
 cc_binary(
@@ -29,6 +31,17 @@ cc_binary(
     srcs = [
         "q1.cc"
             ],
+            deps = [
+                "//lib:embedding_lib",
+                "//lib:instruction_lib",
+                "//lib:utils_lib",
+                "//lib:model_lib",
+                "//scheduler:scheduler"
+            ],
+            copts = [
+                "-std=c++11",
+            ],
+            data = glob(["data/q1*"]),
 )
 
 cc_binary(
@@ -36,6 +49,17 @@ cc_binary(
     srcs = [
         "q2.cc"
             ],
+            deps = [
+                "//lib:embedding_lib",
+                "//lib:instruction_lib",
+                "//lib:utils_lib",
+                "//lib:model_lib",
+                "//scheduler:scheduler"
+            ],
+            copts = [
+                "-std=c++11",
+            ],
+            data = glob(["data/q2*"]),
 )
 
 cc_binary(
@@ -43,6 +67,17 @@ cc_binary(
     srcs = [
         "q3.cc"
             ],
+            deps = [
+                "//lib:embedding_lib",
+                "//lib:instruction_lib",
+                "//lib:utils_lib",
+                "//lib:model_lib",
+                "//scheduler:scheduler"
+            ],
+            copts = [
+                "-std=c++11",
+            ],
+            data = glob(["data/q3*"]),
 )
 
 cc_test(
@@ -56,5 +91,65 @@ cc_test(
         "-O3",
         "-std=c++11",
   ],
-  data = glob(["data/*"]),
+  data = glob(["*"]),
+)
+
+cc_binary(
+    name = "q4",
+    srcs = [
+        "q4.cc"
+            ],
+    deps = [
+        "//lib:embedding_lib",
+        "//lib:instruction_lib",
+        "//lib:utils_lib",
+        "//lib:model_lib",
+        "//scheduler:scheduler"
+    ],
+    copts = [
+        "-std=c++11",
+    ],
+    data = glob(["data/q4*"]),
+    
+)
+
+cc_test(
+  name = "scheduler_test",
+  size = "small",
+  srcs = ["scheduler_test.cc"],
+  deps = [
+      "@gtest//:gtest_main",
+      "//scheduler:scheduler",
+      ],
+  data = glob(["data/q3*"]),
+)
+
+cc_binary(
+    name = "q5",
+    srcs = [
+        "q5.cc"
+            ],
+    deps = [
+        "//lib:embedding_lib",
+        "//lib:instruction_lib",
+        "//lib:utils_lib",
+        "//lib:model_lib",
+        "//q5_lib:q5_optimizer"
+    ],
+    copts = [
+        "-std=c++11",
+    ],
+    data = glob(["data/q4*"]),
+    
+)
+
+cc_test(
+  name = "q5_optimizer_test",
+  size = "small",
+  srcs = ["q5_optimizer_test.cc"],
+  deps = [
+      "@gtest//:gtest_main",
+	  "//q5_lib:q5_optimizer",
+      ],
+  data = glob(["data/q3*"]),
 )
\ No newline at end of file
diff --git a/Thread-1/WORKSPACE b/Thread-1/WORKSPACE
index 6760453..6d24ab2 100644
--- a/Thread-1/WORKSPACE
+++ b/Thread-1/WORKSPACE
@@ -1,15 +1,15 @@
-load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
-
-## google test dependency
-http_archive(
-  name = "gtest",
-  urls = ["https://github.com.cnpmjs.org/google/googletest/archive/refs/tags/release-1.11.0.zip"],
-  strip_prefix = "googletest-release-1.11.0",
-)
-## google benchmark dependency
-http_archive(
-  name = "gbench",
-  urls = ["https://github.com.cnpmjs.org/google/benchmark/archive/refs/tags/v1.6.0.zip"],
-  strip_prefix = "benchmark-1.6.0",
-  sha256 = "3da225763533aa179af8438e994842be5ca72e4a7fed4d7976dc66c8c4502f58"
-)
+load("@bazel_tools//tools/build_defs/repo:http.bzl", "http_archive")
+
+## google test dependency
+http_archive(
+  name = "gtest",
+  urls = ["https://github.com.cnpmjs.org/google/googletest/archive/refs/tags/release-1.11.0.zip"],
+  strip_prefix = "googletest-release-1.11.0",
+)
+## google benchmark dependency
+http_archive(
+  name = "gbench",
+  urls = ["https://github.com.cnpmjs.org/google/benchmark/archive/refs/tags/v1.6.0.zip"],
+  strip_prefix = "benchmark-1.6.0",
+  sha256 = "3da225763533aa179af8438e994842be5ca72e4a7fed4d7976dc66c8c4502f58"
+)
diff --git a/Thread-1/benchmark.cc b/Thread-1/benchmark.cc
index 43b1f43..2c5fc84 100644
--- a/Thread-1/benchmark.cc
+++ b/Thread-1/benchmark.cc
@@ -1,23 +1,23 @@
-/*
- * This file provides an example of how to do automatic benchmark.  Feel free
- * to modify and use this tool.
- */
-
-#include <benchmark/benchmark.h>
-
-static void BM_StringCreation(benchmark::State& state) {
-  for (auto _ : state)
-    std::string empty_string;
-}
-// Register the function as a benchmark
-BENCHMARK(BM_StringCreation);
-
-// Define another benchmark
-static void BM_StringCopy(benchmark::State& state) {
-  std::string x = "hello";
-  for (auto _ : state)
-    std::string copy(x);
-}
-BENCHMARK(BM_StringCopy);
-
+/*
+ * This file provides an example of how to do automatic benchmark.  Feel free
+ * to modify and use this tool.
+ */
+
+#include <benchmark/benchmark.h>
+
+static void BM_StringCreation(benchmark::State& state) {
+  for (auto _ : state)
+    std::string empty_string;
+}
+// Register the function as a benchmark
+BENCHMARK(BM_StringCreation);
+
+// Define another benchmark
+static void BM_StringCopy(benchmark::State& state) {
+  std::string x = "hello";
+  for (auto _ : state)
+    std::string copy(x);
+}
+BENCHMARK(BM_StringCopy);
+
 BENCHMARK_MAIN();
\ No newline at end of file
diff --git a/Thread-1/empty.in b/Thread-1/empty.in
new file mode 100644
index 0000000..e69de29
diff --git a/Thread-1/format.out b/Thread-1/format.out
new file mode 100644
index 0000000..c4b67db
--- /dev/null
+++ b/Thread-1/format.out
@@ -0,0 +1,48 @@
+[OUTPUT]0.921060,0.425797,0.403636,0.030715,-0.885772,-0.247275,0.735561,0.105465,-0.802356,-0.496256,-0.920733,-0.581521,0.935191,0.317238,0.003002,-0.922981
+[OUTPUT]-0.658732,0.818837,0.426621,0.590148,0.699796,-0.583585,-0.054610,0.514838,-0.121474,-0.887865,0.173602,-0.948203,-0.670601,0.020399,0.177220,-0.549446
+[OUTPUT]-0.879334,-0.640228,0.839249,0.023482,-0.540938,0.802633,-0.606537,0.688808,-0.628394,0.101479,0.482763,-0.133030,-0.880715,-0.654144,-0.773193,0.616438
+[OUTPUT]-0.658732,0.818837,0.426621,0.590148,0.699796,-0.583585,-0.054610,0.514838,-0.121474,-0.887865,0.173602,-0.948203,-0.670601,0.020399,0.177220,-0.549446
+[OUTPUT]-0.916672,0.438292,-0.612921,0.773869,-0.044561,0.880783,-0.820628,0.501351,0.857058,0.390680,0.655897,0.001165,0.300883,-0.159834,-0.069333,-0.652656
+[OUTPUT]0.909387,0.427696,0.415396,0.023584,-0.885988,-0.232334,0.737045,0.108910,-0.818352,-0.477376,-0.927423,-0.562243,0.932743,0.326225,0.011571,-0.904000
+[OUTPUT]-0.605347,0.090102,0.609230,-0.364534,-0.016258,0.772092,0.069680,0.182600,-0.823478,0.966173,-0.337044,0.984017,-0.134313,0.452371,0.430428,0.976698
+[OUTPUT]0.993876,-0.818912,0.049160,-0.753035,-0.553889,0.758356,0.554403,-0.623433,-0.259422,0.016790,-0.921738,-0.375217,0.147836,-0.469239,0.462341,0.122965
+[OUTPUT]-0.869508,-0.637887,0.838896,0.014706,-0.535183,0.807111,-0.610846,0.690228,-0.624978,0.098819,0.490698,-0.140691,-0.885881,-0.647397,-0.778868,0.612841
+[OUTPUT]0.984839,0.233648,-0.035815,-0.879602,0.575782,0.449158,-0.431495,0.141676,0.342281,-0.265620,0.794551,-0.766425,-0.516771,0.675741,-0.568578,-0.359764
+[OUTPUT]-0.013662,-0.328149,0.638905,0.130879,0.633231,-0.389049,-0.330547,-0.507696,-0.157492,0.062884,0.253735,0.800204,0.745938,0.144718,-0.239747,0.719049
+[OUTPUT]-0.648886,0.821173,0.426263,0.581354,0.705553,-0.579094,-0.058924,0.516255,-0.118052,-0.890520,0.181546,-0.955866,-0.675767,0.027155,0.171536,-0.553043
+[OUTPUT]1.004079,-0.366647,0.859724,-0.122036,0.419513,0.686716,-0.383791,-0.643428,-0.025409,0.650472,0.390644,0.321168,0.816956,-0.988946,0.775094,0.357803
+[OUTPUT]0.964548,0.007197,0.384946,-0.415350,0.618330,0.751295,0.977606,-0.521950,-0.606579,0.639509,-0.775349,-0.319479,0.831076,-0.240864,0.654817,-0.718152
+[OUTPUT]0.103926,-0.996023,0.243298,-0.007219,-0.461952,-0.227753,0.517099,-0.768876,0.619788,-0.717524,-0.646730,-0.403424,-0.755709,-0.912842,0.062405,0.920623
+[OUTPUT]0.532214,0.234569,0.184321,-0.704645,0.023340,0.786531,0.567961,-0.282830,-0.368144,-0.901147,0.473634,-0.263915,-0.433691,-0.688961,-0.815372,-0.945467
+[OUTPUT]0.765234,-0.201392,-0.000533,0.774873,0.458159,-0.795103,-0.000813,0.686313,-0.377074,-0.529460,-0.005927,0.242799,0.916452,-0.507848,-0.367214,0.943209
+[OUTPUT]0.722277,-0.005455,-0.291513,-0.775073,0.117238,0.593836,-0.010768,0.707408,-0.511233,-0.781110,0.009952,-0.973220,0.558455,0.110520,-0.569440,-0.599438
+[OUTPUT]0.161624,-0.387043,-0.248548,0.306342,-0.958972,-0.282676,0.322154,-0.149104,0.982688,0.850894,0.635758,-0.576914,0.093768,-0.782197,-0.466389,-0.831633
+[OUTPUT]0.678175,0.339051,0.856835,-0.804427,0.887768,-0.422033,0.301859,0.425874,0.251634,-0.077383,0.273105,0.780718,0.898884,0.644176,0.635907,-0.116260
+[OUTPUT]-0.073554,-0.599148,0.488816,0.894666,-0.371995,-0.840192,-0.591994,0.157122,0.450549,-0.899667,-0.879198,-0.037612,-0.570074,-0.938749,-0.872622,-0.755112
+[OUTPUT]0.735760,0.526643,-0.826290,0.688215,-0.750647,-0.049823,-0.794992,-0.442351,-0.988222,-0.444103,0.551925,0.651644,-0.316369,0.663358,-0.143058,-0.917498
+[OUTPUT]0.689027,0.886214,-0.459371,-0.131004,0.367658,0.261314,-0.126670,-0.410393,0.575357,-0.541183,0.796069,-0.162909,-0.122641,0.872275,-0.579420,-0.597069
+[OUTPUT]-0.021703,0.697649,-0.112268,-0.862253,0.783593,0.186018,0.409477,0.440772,-0.695785,-0.661023,0.386730,-0.150323,0.099550,0.895029,0.708054,-0.309297
+[OUTPUT]0.000000,0.100000,0.200000,0.300000,0.400000,0.500000,0.600000,0.700000,0.800000,0.900000,1.000000,1.100000,1.200000,1.300000,1.400000,1.500000
+[OUTPUT]0.000000,0.100000,0.200000,0.300000,0.400000,0.500000,0.600000,0.700000,0.800000,0.900000,1.000000,1.100000,1.200000,1.300000,1.400000,1.500000
+[OUTPUT]0.000000,0.100000,0.200000,0.300000,0.400000,0.500000,0.600000,0.700000,0.800000,0.900000,1.000000,1.100000,1.200000,1.300000,1.400000,1.500000
+[OUTPUT]0.000000,0.100000,0.200000,0.300000,0.400000,0.500000,0.600000,0.700000,0.800000,0.900000,1.000000,1.100000,1.200000,1.300000,1.400000,1.500000
+[OUTPUT]-0.916672,0.438292,-0.612921,0.773869,-0.044561,0.880783,-0.820628,0.501351,0.857058,0.390680,0.655897,0.001165,0.300884,-0.159834,-0.069333,-0.652656
+[OUTPUT]0.921060,0.425797,0.403636,0.030715,-0.885772,-0.247275,0.735561,0.105465,-0.802356,-0.496256,-0.920733,-0.581521,0.935191,0.317238,0.003002,-0.922981
+[OUTPUT]-0.594760,0.097336,0.601636,-0.364712,-0.012584,0.763592,0.077184,0.175923,-0.818774,0.964197,-0.343675,0.984219,-0.123681,0.459535,0.438168,0.968739
+[OUTPUT]0.993888,-0.818917,0.049171,-0.753037,-0.553882,0.758365,0.554397,-0.623441,-0.259421,0.016799,-0.921732,-0.375213,0.147846,-0.469252,0.462351,0.122971
+[OUTPUT]-0.879930,-0.640132,0.839850,0.023118,-0.540949,0.803397,-0.606462,0.688984,-0.629211,0.102444,0.482422,-0.132045,-0.880841,-0.653685,-0.772755,0.617409
+[OUTPUT]0.983303,0.233827,-0.034550,-0.878989,0.575942,0.449376,-0.432155,0.142879,0.341532,-0.266406,0.795207,-0.767506,-0.518320,0.675108,-0.569173,-0.359698
+[OUTPUT]-0.013662,-0.328149,0.638905,0.130879,0.633231,-0.389049,-0.330547,-0.507696,-0.157492,0.062884,0.253735,0.800204,0.745938,0.144718,-0.239747,0.719049
+[OUTPUT]-0.658732,0.818837,0.426621,0.590148,0.699796,-0.583585,-0.054610,0.514838,-0.121474,-0.887865,0.173602,-0.948203,-0.670601,0.020399,0.177220,-0.549446
+[OUTPUT]0.994450,-0.366718,0.855882,-0.117889,0.413343,0.679216,-0.393549,-0.638217,-0.019354,0.644089,0.398384,0.324358,0.808660,-0.986542,0.768558,0.364971
+[OUTPUT]0.965541,0.006831,0.385801,-0.415467,0.618743,0.751973,0.977213,-0.522587,-0.606599,0.640152,-0.774952,-0.319155,0.831884,-0.241849,0.655584,-0.717788
+[OUTPUT]0.103926,-0.996023,0.243298,-0.007219,-0.461952,-0.227753,0.517099,-0.768876,0.619788,-0.717524,-0.646730,-0.403424,-0.755709,-0.912842,0.062405,0.920623
+[OUTPUT]0.532214,0.234569,0.184321,-0.704645,0.023340,0.786531,0.567961,-0.282830,-0.368144,-0.901147,0.473634,-0.263915,-0.433691,-0.688961,-0.815372,-0.945467
+[OUTPUT]0.765234,-0.201392,-0.000533,0.774873,0.458159,-0.795103,-0.000813,0.686313,-0.377074,-0.529460,-0.005927,0.242799,0.916452,-0.507848,-0.367214,0.943209
+[OUTPUT]0.722277,-0.005455,-0.291513,-0.775073,0.117238,0.593836,-0.010768,0.707408,-0.511233,-0.781110,0.009952,-0.973220,0.558455,0.110520,-0.569440,-0.599438
+[OUTPUT]0.161624,-0.387043,-0.248548,0.306342,-0.958972,-0.282676,0.322154,-0.149104,0.982688,0.850894,0.635758,-0.576914,0.093768,-0.782197,-0.466389,-0.831633
+[OUTPUT]0.678175,0.339051,0.856835,-0.804427,0.887768,-0.422033,0.301859,0.425874,0.251634,-0.077383,0.273105,0.780718,0.898884,0.644176,0.635907,-0.116260
+[OUTPUT]-0.073554,-0.599148,0.488816,0.894666,-0.371995,-0.840192,-0.591994,0.157122,0.450549,-0.899667,-0.879198,-0.037612,-0.570074,-0.938749,-0.872622,-0.755112
+[OUTPUT]0.735760,0.526643,-0.826290,0.688215,-0.750647,-0.049823,-0.794992,-0.442351,-0.988222,-0.444103,0.551925,0.651644,-0.316369,0.663358,-0.143058,-0.917498
+[OUTPUT]0.689027,0.886214,-0.459371,-0.131004,0.367658,0.261314,-0.126670,-0.410393,0.575357,-0.541183,0.796069,-0.162909,-0.122641,0.872275,-0.579420,-0.597069
+[OUTPUT]-0.021703,0.697649,-0.112268,-0.862253,0.783593,0.186018,0.409477,0.440772,-0.695785,-0.661023,0.386730,-0.150323,0.099550,0.895029,0.708054,-0.309297
diff --git a/Thread-1/init_optimizer/BUILD b/Thread-1/init_optimizer/BUILD
new file mode 100644
index 0000000..157fa9c
--- /dev/null
+++ b/Thread-1/init_optimizer/BUILD
@@ -0,0 +1,32 @@
+##load("@rules_cc//cc:defs.bzl", "cc_test")  #load the test target
+
+cc_library(
+    name = "init_optimizer",
+    srcs = [
+        "init_optimizer.cc",
+        ],
+    hdrs = [
+        "init_optimizer.h",
+        ],
+    deps = [
+        "//lib:embedding_lib",
+        "//lib:model_lib"
+    ],
+    linkopts = [
+        "-pthread"
+    ],
+
+	visibility = [
+		"//visibility:public",
+	],
+)
+
+cc_test(
+  name = "init_optimizer_test",
+  size = "small",
+  srcs = ["init_optimizer_test.cc"],
+  deps = [
+      "@gtest//:gtest_main",
+	  ":init_optimizer",
+      ],
+)
\ No newline at end of file
diff --git a/Thread-1/init_optimizer/init_optimizer.cc b/Thread-1/init_optimizer/init_optimizer.cc
new file mode 100644
index 0000000..6fc1062
--- /dev/null
+++ b/Thread-1/init_optimizer/init_optimizer.cc
@@ -0,0 +1,42 @@
+#include <thread>
+#include <iostream>
+#include "init_optimizer.h"
+namespace proj1 {
+    Init_Optimizer::Init_Optimizer(Embedding newuser) {
+        this -> user = newuser;
+        double* data = new double[this -> user.get_length()];
+        this -> gradient = EmbeddingGradient(this -> user.get_length(),data );
+     }
+
+    void Init_Optimizer::add_item(Embedding* item) {
+        this -> items -> append(item);
+    }
+
+    Embedding Init_Optimizer::output_grad() {
+        return this -> gradient;
+    }
+
+    void Init_Optimizer::compute() {
+        int num_items = this -> items -> get_n_embeddings();
+        std::vector<std::thread> thread_list;
+        for (int i = 0; i < num_items; i ++) {
+            Embedding* item = this -> items -> get_embedding(i);
+            thread_list.push_back(std::thread(&Init_Optimizer::single_thread, this, item));
+        }
+
+        for (int i = 0; i < num_items; i ++) {
+            thread_list[i].join();
+        }
+    }
+
+    void Init_Optimizer::single_thread(Embedding* item) {
+        EmbeddingGradient* grad = cold_start(&this -> user, item);
+        // std::cout<<"grad:"<<std::endl;
+        // grad->write_to_stdout();
+        this -> mux.lock();
+        this -> gradient = this -> gradient + grad;
+        // std::cout<<"gradient:"<<std::endl;
+        // this -> gradient.write_to_stdout();
+        this -> mux.unlock();
+    }
+}
\ No newline at end of file
diff --git a/Thread-1/init_optimizer/init_optimizer.h b/Thread-1/init_optimizer/init_optimizer.h
new file mode 100644
index 0000000..f8c5fa5
--- /dev/null
+++ b/Thread-1/init_optimizer/init_optimizer.h
@@ -0,0 +1,33 @@
+//This package parallelize the INIT_EMB instruction execution
+#ifndef THREAD_INIT_OPTIMIZER_H_
+#define THREAD_INIT_OPTIMIZER_H_
+
+#include <mutex>
+#include <vector>
+#include <stdlib.h>
+
+#include "../lib/embedding.h"
+#include "../lib/model.h"
+
+
+
+namespace proj1 {
+    class Init_Optimizer {
+        public:
+            Init_Optimizer(Embedding newuser);
+            //~Init_Optimizer() 
+            
+            void add_item(Embedding*);
+            EmbeddingGradient output_grad();
+            void compute();
+            void single_thread(Embedding* item);//single cold start
+        private:
+            EmbeddingHolder* items =new EmbeddingHolder(*(new EmbeddingMatrix));
+            Embedding user;
+            EmbeddingGradient gradient;
+            std::mutex mux;
+    };
+};
+
+
+#endif // THREAD_LIB_EMBEDDING_H_
\ No newline at end of file
diff --git a/Thread-1/init_optimizer/init_optimizer_test.cc b/Thread-1/init_optimizer/init_optimizer_test.cc
new file mode 100644
index 0000000..a21c6e2
--- /dev/null
+++ b/Thread-1/init_optimizer/init_optimizer_test.cc
@@ -0,0 +1,92 @@
+#include <gtest/gtest.h>
+#include <vector>
+#include "init_optimizer.h"
+
+
+double vecA[20] = {-0.9166718150866153,0.43829227278389205,-0.6129205231425989,0.7738693110376684,-0.04456069156634124,0.8807831166061564,-0.8206278700342509,0.5013513447020947,0.8570578529268591,0.3906799520892723,0.6558968505921785,0.0011654760044317314,0.3008835791217257,-0.15983430198414705,-0.0693333837225647,-0.6526558237637923};
+double vecB[20] = {0.9210598583969818,0.42579710374854174,0.4036360259825613,0.030714658443632636,-0.885772459758438,-0.24727514094877123,0.7355606108008894,0.10546495518591437,-0.8023562184533268,-0.49625645997262624,-0.9207327565798142,-0.5815206606673406,0.9351907452001367,0.3172382122419557,0.003001769800845988,-0.922981014248552};
+
+namespace proj1 {
+namespace testing{
+
+class InitOptimizerTest : public ::testing::Test {
+ protected:
+  void SetUp() override {
+    embA = new Embedding(20, vecA);
+	embB = new Embedding(20, vecB);
+	optimA = new Init_Optimizer(*embA);
+	optimB = new Init_Optimizer(*embB);
+	optimA_ = new Init_Optimizer(*embA);
+	optimB_ = new Init_Optimizer(*embB);
+  }
+  Embedding* embA;
+  Embedding* embB;
+  Init_Optimizer* optimA;
+  Init_Optimizer* optimB;
+  Init_Optimizer* optimA_;
+  Init_Optimizer* optimB_;
+};
+
+bool compare(Embedding emb1, Embedding emb2){
+	double * tmp1 = emb1.get_data();
+	double * tmp2 = emb2.get_data();
+	for(int i = 0; i<20; i++){
+		if(tmp1[i]!=tmp2[i])return false;
+	}
+	return true;
+}
+
+TEST_F(InitOptimizerTest, test_compute){
+
+	EmbeddingGradient gradA = optimA->output_grad();
+	EmbeddingGradient gradB = optimB->output_grad();
+	EmbeddingGradient grad0 = EmbeddingGradient(20, new double[20]);
+	EXPECT_EQ(true, compare(gradA, gradB));
+	EXPECT_EQ(true, compare(gradA, grad0));
+	EXPECT_EQ(true, compare(gradB, grad0));
+
+	EmbeddingGradient* gradA_A = cold_start(embA, embA);
+	// gradA_A->write_to_stdout();
+	EmbeddingGradient* gradA_B = cold_start(embA, embB);
+	// gradA_B->write_to_stdout();
+	EmbeddingGradient* gradB_A = cold_start(embB, embA);
+	// gradB_A->write_to_stdout();
+	EmbeddingGradient* gradB_B = cold_start(embB, embB);
+	// gradB_B->write_to_stdout();
+
+	optimA->add_item(embA);
+	optimB->add_item(embA);
+	optimA->compute();
+	optimB->compute();
+	gradA = gradA + gradA_A;
+	gradB = gradB + gradB_A;
+	EXPECT_EQ(true, compare(gradA, grad0+gradA_A));
+	EXPECT_EQ(true, compare(gradA, optimA->output_grad()));
+	EXPECT_EQ(true, compare(grad0+gradA_A, optimA->output_grad()));
+	EXPECT_EQ(true, compare(gradB, grad0+gradB_A));
+	EXPECT_EQ(true, compare(gradB, optimB->output_grad()));
+	EXPECT_EQ(true, compare(grad0+gradB_A, optimB->output_grad()));
+
+	optimA_->add_item(embA);
+	optimA_->add_item(embB);
+	optimB_->add_item(embA);
+	optimB_->add_item(embB);
+
+	optimA_->compute();
+	optimB_->compute();
+	gradA = gradA + gradA_B;
+	gradB = gradB + gradB_B;
+	EXPECT_EQ(true, compare(gradA, grad0+gradA_A+gradA_B));
+	EXPECT_EQ(true, compare(gradA, optimA_->output_grad()));
+	EXPECT_EQ(true, compare(grad0+gradA_A+gradA_B, optimA_->output_grad()));
+	EXPECT_EQ(true, compare(gradB, grad0+gradB_A+gradB_B));
+	EXPECT_EQ(true, compare(gradB, optimB_->output_grad()));
+	EXPECT_EQ(true, compare(grad0+gradB_A+gradB_B, optimB_->output_grad()));
+}
+} // namespace testing
+} // namespace proj1
+
+int main(int argc,char **argv){
+  testing::InitGoogleTest(&argc,argv);
+  return RUN_ALL_TESTS();
+}
diff --git a/Thread-1/lib/embedding.cc b/Thread-1/lib/embedding.cc
index 966a76d..a2e9b9e 100644
--- a/Thread-1/lib/embedding.cc
+++ b/Thread-1/lib/embedding.cc
@@ -142,6 +142,8 @@ bool Embedding::operator==(const Embedding &another) {
     return true;
 }
 
+
+
 EmbeddingHolder::EmbeddingHolder(std::string filename) {
     this->emb_matx = this->read(filename);
 }
@@ -175,8 +177,9 @@ EmbeddingMatrix EmbeddingHolder::read(std::string filename) {
 
 int EmbeddingHolder::append(Embedding* data) {
     int indx = this->emb_matx.size();
+
     embbedingAssert(
-        data->get_length() == this->emb_matx[0]->get_length(),
+        (this->emb_matx.size() == 0) ||( data->get_length() == this->emb_matx[0]->get_length()),
         "Embedding to append has a different length!", LEN_MISMATCH
     );
     this->emb_matx.push_back(data);
diff --git a/Thread-1/lib/embedding.h b/Thread-1/lib/embedding.h
index 6e13d14..1da55b4 100644
--- a/Thread-1/lib/embedding.h
+++ b/Thread-1/lib/embedding.h
@@ -4,6 +4,7 @@
 #include <string>
 #include <vector>
 
+
 namespace proj1 {
 
 enum EMBEDDING_ERROR {
@@ -18,7 +19,7 @@ public:
     Embedding(int, double*);
     Embedding(int, std::string);
     Embedding(Embedding*);
-    ~Embedding() { delete []this->data; }
+    //~Embedding() { delete []this->data; }
     double* get_data() { return this->data; }
     int get_length() { return this->length; }
     void update(Embedding*, double);
@@ -34,14 +35,22 @@ public:
     Embedding operator/(const Embedding&);
     Embedding operator/(const double);
     bool operator==(const Embedding&);
+
+    //void calc_gradient_and_set(Embedding*, Embedding*, int);
+
 private:
     int length;
     double* data;
 };
 
 using EmbeddingMatrix = std::vector<Embedding*>;
+
 using EmbeddingGradient = Embedding;
 
+
+
+
+
 class EmbeddingHolder{
 public:
     EmbeddingHolder(std::string filename);
diff --git a/Thread-1/lib/instruction.cc b/Thread-1/lib/instruction.cc
index ddfc532..75879c5 100644
--- a/Thread-1/lib/instruction.cc
+++ b/Thread-1/lib/instruction.cc
@@ -1,31 +1,31 @@
-#include <string>
-#include <sstream>
-#include <fstream>
-#include "instruction.h"
-
-namespace proj1 {
-
-Instruction::Instruction(std::string line) {
-    std::stringstream ss(line);
-    int data;
-    ss >> data;
-    this->order = (InstructionOrder) data;
-    while (ss >> data) {
-        this->payloads.push_back(data);
-    }
-}
-
-Instructions read_instructrions(std::string filename) {
-    std::ifstream ifs(filename);
-    std::string line;
-    Instructions data;
-    if (ifs.is_open()) {
-        while(std::getline(ifs, line)) {
-            data.push_back(Instruction(line));
-        }
-        ifs.close();
-    }
-    return data;
-}
-
+#include <string>
+#include <sstream>
+#include <fstream>
+#include "instruction.h"
+
+namespace proj1 {
+
+Instruction::Instruction(std::string line) {
+    std::stringstream ss(line);
+    int data;
+    ss >> data;
+    this->order = (InstructionOrder) data;
+    while (ss >> data) {
+        this->payloads.push_back(data);
+    }
+}
+
+Instructions read_instructions(std::string filename) {
+    std::ifstream ifs(filename);
+    std::string line;
+    Instructions data;
+    if (ifs.is_open()) {
+        while(std::getline(ifs, line)) {
+            data.push_back(Instruction(line));
+        }
+        ifs.close();
+    }
+    return data;
+}
+
 } // namespace proj1
\ No newline at end of file
diff --git a/Thread-1/lib/instruction.h b/Thread-1/lib/instruction.h
index 4aa34ea..eb7d81c 100644
--- a/Thread-1/lib/instruction.h
+++ b/Thread-1/lib/instruction.h
@@ -1,26 +1,26 @@
-#ifndef THREAD_LIB_INSTRUCTION_H_
-#define THREAD_LIB_INSTRUCTION_H_
-
-#include <string>
-#include <vector>
-
-namespace proj1 {
-
-enum InstructionOrder {
-    INIT_EMB = 0,
-    UPDATE_EMB,
-    RECOMMEND
-};
-
-struct Instruction {
-    Instruction(std::string);
-    InstructionOrder order;
-    std::vector<int> payloads;
-};
-
-using Instructions = std::vector<Instruction>;
-
-Instructions read_instructrions(std::string);
-
-} // namespace proj1
+#ifndef THREAD_LIB_INSTRUCTION_H_
+#define THREAD_LIB_INSTRUCTION_H_
+
+#include <string>
+#include <vector>
+
+namespace proj1 {
+
+enum InstructionOrder {
+    INIT_EMB =     0,
+    UPDATE_EMB, // 1
+    RECOMMEND   // 2
+};
+
+struct Instruction {
+    Instruction(std::string);
+    InstructionOrder order;
+    std::vector<int> payloads;
+};
+
+using Instructions = std::vector<Instruction>;
+
+Instructions read_instructions(std::string);
+
+} // namespace proj1
 #endif  // THREAD_LIB_INSTRUCTION_H_
\ No newline at end of file
diff --git a/Thread-1/lib/utils.cc b/Thread-1/lib/utils.cc
index 3427314..6318dfe 100644
--- a/Thread-1/lib/utils.cc
+++ b/Thread-1/lib/utils.cc
@@ -1,45 +1,45 @@
-#include <cmath>
-#include <string>
-#include <iostream>
-#include <chrono>
-#include <thread>
-#include "utils.h"
-
-namespace proj1 {
-
-void a_slow_function(int seconds) {
-    //std::this_thread::sleep_for(std::chrono::seconds(seconds));
-}
-
-double sigmoid(double x) {
-    return 1.0 / (1.0 + exp(-x));
-}
-
-double sigmoid_backward(double x) {
-    double y = sigmoid(x);
-    return y * (1.0 - y);
-}
-
-double binary_cross_entropy(double y_true, double y_pred) {
-    double eps = 1e-8;
-    return y_true * log(eps + y_pred) \
-        + (1.0 - y_true) * log(1.0 - y_pred + eps);
-}
-
-double binary_cross_entropy_backward(double y_true, double y_pred) {
-    double eps = 1e-8;
-    return (y_true - y_pred) / (eps + (1.0 - y_pred) * y_pred);
-}
-
-AutoTimer::AutoTimer(std::string name) : 
-        m_name(std::move(name)),
-        m_beg(std::chrono::high_resolution_clock::now()) { 
-    }
-
-AutoTimer::~AutoTimer() {
-    auto end = std::chrono::high_resolution_clock::now();
-    auto dur = std::chrono::duration_cast<std::chrono::microseconds>(end - m_beg);
-    std::cout << m_name << " : " << dur.count() << " usec\n";
-}
-
-} // namespace proj1
+#include <cmath>
+#include <string>
+#include <iostream>
+#include <chrono>
+#include <thread>
+#include "utils.h"
+
+namespace proj1 {
+
+void a_slow_function(int seconds) {
+    std::this_thread::sleep_for(std::chrono::seconds(seconds));
+}
+
+double sigmoid(double x) {
+    return 1.0 / (1.0 + exp(-x));
+}
+
+double sigmoid_backward(double x) {
+    double y = sigmoid(x);
+    return y * (1.0 - y);
+}
+
+double binary_cross_entropy(double y_true, double y_pred) {
+    double eps = 1e-8;
+    return y_true * log(eps + y_pred) \
+        + (1.0 - y_true) * log(1.0 - y_pred + eps);
+}
+
+double binary_cross_entropy_backward(double y_true, double y_pred) {
+    double eps = 1e-8;
+    return (y_true - y_pred) / (eps + (1.0 - y_pred) * y_pred);
+}
+
+AutoTimer::AutoTimer(std::string name) : 
+        m_name(std::move(name)),
+        m_beg(std::chrono::high_resolution_clock::now()) { 
+    }
+
+AutoTimer::~AutoTimer() {
+    auto end = std::chrono::high_resolution_clock::now();
+    auto dur = std::chrono::duration_cast<std::chrono::microseconds>(end - m_beg);
+    std::cout << m_name << " : " << dur.count() << " usec\n";
+}
+
+} // namespace proj1
diff --git a/Thread-1/q0.cc b/Thread-1/q0.cc
index 7e51849..db786ee 100644
--- a/Thread-1/q0.cc
+++ b/Thread-1/q0.cc
@@ -1,92 +1,92 @@
-#include <vector>
-#include <tuple>
-
-#include <string>   // string
-#include <chrono>   // timer
-#include <iostream> // cout, endl
-
-#include "lib/utils.h"
-#include "lib/model.h" 
-#include "lib/embedding.h" 
-#include "lib/instruction.h"
-
-namespace proj1 {
-
-void run_one_instruction(Instruction inst, EmbeddingHolder* users, EmbeddingHolder* items) {
-    switch(inst.order) {
-        case INIT_EMB: {
-            // We need to init the embedding
-            int length = users->get_emb_length();
-            Embedding* new_user = new Embedding(length);
-            int user_idx = users->append(new_user);
-            for (int item_index: inst.payloads) {
-                Embedding* item_emb = items->get_embedding(item_index);
-                // Call cold start for downstream applications, slow
-                EmbeddingGradient* gradient = cold_start(new_user, item_emb);
-                users->update_embedding(user_idx, gradient, 0.01);
-                delete gradient;
-            }
-            break;
-        }
-        case UPDATE_EMB: {
-            int user_idx = inst.payloads[0];
-            int item_idx = inst.payloads[1];
-            int label = inst.payloads[2];
-            // You might need to add this state in other questions.
-            // Here we just show you this as an example
-            // int epoch = -1;
-            //if (inst.payloads.size() > 3) {
-            //    epoch = inst.payloads[3];
-            //}
-            Embedding* user = users->get_embedding(user_idx);
-            Embedding* item = items->get_embedding(item_idx);
-            EmbeddingGradient* gradient = calc_gradient(user, item, label);
-            users->update_embedding(user_idx, gradient, 0.01);
-            delete gradient;
-            gradient = calc_gradient(item, user, label);
-            items->update_embedding(item_idx, gradient, 0.001);
-            delete gradient;
-            break;
-        }
-        case RECOMMEND: {
-            int user_idx = inst.payloads[0];
-            Embedding* user = users->get_embedding(user_idx);
-            std::vector<Embedding*> item_pool;
-            int iter_idx = inst.payloads[1];
-            for (unsigned int i = 2; i < inst.payloads.size(); ++i) {
-                int item_idx = inst.payloads[i];
-                item_pool.push_back(items->get_embedding(item_idx));
-            }
-            Embedding* recommendation = recommend(user, item_pool);
-            recommendation->write_to_stdout();
-            break;
-        }
-    }
-
-}
-} // namespace proj1
-
-int main(int argc, char *argv[]) {
-
-    proj1::EmbeddingHolder* users = new proj1::EmbeddingHolder("data/q0.in");
-    proj1::EmbeddingHolder* items = new proj1::EmbeddingHolder("data/q0.in");
-    proj1::Instructions instructions = proj1::read_instructrions("data/q0_instruction.tsv");
-    {
-    proj1::AutoTimer timer("q0");  // using this to print out timing of the block
-    // Run all the instructions
-    for (proj1::Instruction inst: instructions) {
-        proj1::run_one_instruction(inst, users, items);
-    }
-    }
-
-    // Write the result
-    users->write_to_stdout();
-    items->write_to_stdout();
-
-    // We only need to delete the embedding holders, as the pointers are all
-    // pointing at the emb_matx of the holders.
-    delete users;
-    delete items;
-
-    return 0;
-}
+#include <vector>
+#include <tuple>
+
+#include <string>   // string
+#include <chrono>   // timer
+#include <iostream> // cout, endl
+
+#include "lib/utils.h"
+#include "lib/model.h" 
+#include "lib/embedding.h" 
+#include "lib/instruction.h"
+
+namespace proj1 {
+
+void run_one_instruction(Instruction inst, EmbeddingHolder* users, EmbeddingHolder* items) {
+    switch(inst.order) {
+        case INIT_EMB: {
+            // We need to init the embedding
+            int length = users->get_emb_length();
+            Embedding* new_user = new Embedding(length);
+            int user_idx = users->append(new_user);
+            for (int item_index: inst.payloads) {
+                Embedding* item_emb = items->get_embedding(item_index);
+                // Call cold start for downstream applications, slow
+                EmbeddingGradient* gradient = cold_start(new_user, item_emb);
+                users->update_embedding(user_idx, gradient, 0.01);
+                delete gradient;
+            }
+            break;
+        }
+        case UPDATE_EMB: {
+            int user_idx = inst.payloads[0];
+            int item_idx = inst.payloads[1];
+            int label = inst.payloads[2];
+            // You might need to add this state in other questions.
+            // Here we just show you this as an example
+            // int epoch = -1;
+            //if (inst.payloads.size() > 3) {
+            //    epoch = inst.payloads[3];
+            //}
+            Embedding* user = users->get_embedding(user_idx);
+            Embedding* item = items->get_embedding(item_idx);
+            EmbeddingGradient* gradient = calc_gradient(user, item, label);
+            users->update_embedding(user_idx, gradient, 0.01);
+            delete gradient;
+            gradient = calc_gradient(item, user, label);
+            items->update_embedding(item_idx, gradient, 0.001);
+            delete gradient;
+            break;
+        }
+        case RECOMMEND: {
+            int user_idx = inst.payloads[0];
+            Embedding* user = users->get_embedding(user_idx);
+            std::vector<Embedding*> item_pool;
+            int iter_idx = inst.payloads[1];
+            for (unsigned int i = 2; i < inst.payloads.size(); ++i) {
+                int item_idx = inst.payloads[i];
+                item_pool.push_back(items->get_embedding(item_idx));
+            }
+            Embedding* recommendation = recommend(user, item_pool);
+            recommendation->write_to_stdout();
+            break;
+        }
+    }
+
+}
+} // namespace proj1
+
+int main(int argc, char *argv[]) {
+
+    proj1::EmbeddingHolder* users = new proj1::EmbeddingHolder("data/q0.in");
+    proj1::EmbeddingHolder* items = new proj1::EmbeddingHolder("data/q0.in");
+    proj1::Instructions instructions = proj1::read_instructions("data/q0_instruction.tsv");
+    {
+    proj1::AutoTimer timer("q0");  // using this to print out timing of the block
+    // Run all the instructions
+    for (proj1::Instruction inst: instructions) {
+        proj1::run_one_instruction(inst, users, items);
+    }
+    }
+
+    // Write the result
+    users->write_to_stdout();
+    items->write_to_stdout();
+
+    // We only need to delete the embedding holders, as the pointers are all
+    // pointing at the emb_matx of the holders.
+    delete users;
+    delete items;
+
+    return 0;
+}
\ No newline at end of file
diff --git a/Thread-1/q1.cc b/Thread-1/q1.cc
index 974ad23..89c538c 100644
--- a/Thread-1/q1.cc
+++ b/Thread-1/q1.cc
@@ -1,5 +1,26 @@
-#include <iostream> // cout, endl
-int main(int argc, char *argv[]) {
-    std::cout << "please implement this function\n";
-    exit(1);
+#include <vector>
+#include <tuple>
+
+#include <string>   // string
+#include <chrono>   // timer
+#include <iostream> // cout, endl
+
+#include "lib/utils.h"
+#include "lib/model.h" 
+#include "lib/embedding.h" 
+#include "lib/instruction.h"
+
+#include "scheduler/scheduler.h"
+
+
+int main(int argc, char *argv[]) {
+
+    
+    
+    
+    proj1::Scheduler* scheduler = new proj1::Scheduler("data/q1.in","data/q1.in","data/q1_instruction.tsv");
+    proj1::AutoTimer timer("q1");
+    scheduler -> execute_all();
+    scheduler -> write_to_stdout();
+    return 0;
 }
\ No newline at end of file
diff --git a/Thread-1/q2.cc b/Thread-1/q2.cc
index c4b7413..10d4bf1 100644
--- a/Thread-1/q2.cc
+++ b/Thread-1/q2.cc
@@ -1,4 +1,24 @@
-#include <iostream> // cout, endl
-int main(int argc, char *argv[]) {
-    exit(1);
+#include <vector>
+#include <tuple>
+
+#include <string>   // string
+#include <chrono>   // timer
+#include <iostream> // cout, endl
+
+#include "lib/utils.h"
+#include "lib/model.h" 
+#include "lib/embedding.h" 
+#include "lib/instruction.h"
+
+#include "scheduler/scheduler.h"
+int main(int argc, char *argv[]) {
+
+    
+    
+    
+    proj1::Scheduler* scheduler = new proj1::Scheduler("data/q2.in","data/q2.in","data/q2_instruction.tsv");
+    proj1::AutoTimer timer("q2");
+    scheduler -> execute_all();
+    scheduler -> write_to_stdout();
+    return 0;
 }
\ No newline at end of file
diff --git a/Thread-1/q3.cc b/Thread-1/q3.cc
index c4b7413..371eb13 100644
--- a/Thread-1/q3.cc
+++ b/Thread-1/q3.cc
@@ -1,4 +1,26 @@
-#include <iostream> // cout, endl
-int main(int argc, char *argv[]) {
-    exit(1);
+#include <vector>
+#include <tuple>
+
+#include <string>   // string
+#include <chrono>   // timer
+#include <iostream> // cout, endl
+
+#include "lib/utils.h"
+#include "lib/model.h" 
+#include "lib/embedding.h" 
+#include "lib/instruction.h"
+
+#include "scheduler/scheduler.h"
+
+
+int main(int argc, char *argv[]) {
+
+    
+    
+    
+    proj1::Scheduler* scheduler = new proj1::Scheduler("data/q3.in","data/q3.in","data/q3_instruction.tsv");
+    proj1::AutoTimer timer("q3");
+    scheduler -> execute_all();
+    scheduler -> write_to_stdout();
+    return 0;
 }
\ No newline at end of file
diff --git a/Thread-1/q4.cc b/Thread-1/q4.cc
new file mode 100644
index 0000000..cf29074
--- /dev/null
+++ b/Thread-1/q4.cc
@@ -0,0 +1,26 @@
+#include <vector>
+#include <tuple>
+
+#include <string>   // string
+#include <chrono>   // timer
+#include <iostream> // cout, endl
+
+#include "lib/utils.h"
+#include "lib/model.h" 
+#include "lib/embedding.h" 
+#include "lib/instruction.h"
+
+#include "scheduler/scheduler.h"
+
+
+int main(int argc, char *argv[]) {
+
+    
+    
+    
+    proj1::Scheduler* scheduler = new proj1::Scheduler("data/q4.in","data/q4.in","data/q4_instruction.tsv");
+    proj1::AutoTimer timer("q4");
+    scheduler -> execute_all();
+    //scheduler -> write_to_stdout();
+    return 0;
+}
\ No newline at end of file
diff --git a/Thread-1/q5.cc b/Thread-1/q5.cc
index c4b7413..2aa09ec 100644
--- a/Thread-1/q5.cc
+++ b/Thread-1/q5.cc
@@ -1,4 +1,25 @@
+#include <vector>
+#include <tuple>
+
+#include <string>   // string
+#include <chrono>   // timer
 #include <iostream> // cout, endl
+
+#include "lib/utils.h"
+#include "lib/model.h" 
+#include "lib/embedding.h" 
+#include "lib/instruction.h"
+
+#include "q5_lib/q5_optimizer.h"
+
+
 int main(int argc, char *argv[]) {
-    exit(1);
+
+    proj1::Optimizer* optim = new proj1::Optimizer("data/q4.in","data/q4.in","data/q4_instruction.tsv");
+    proj1::AutoTimer timer("q5");
+    optim -> execute_all();
+    //scheduler -> write_to_stdout();
+    optim -> clear();
+    return 0;
+
 }
\ No newline at end of file
diff --git a/Thread-1/q5_lib/BUILD b/Thread-1/q5_lib/BUILD
new file mode 100644
index 0000000..7db16c1
--- /dev/null
+++ b/Thread-1/q5_lib/BUILD
@@ -0,0 +1,23 @@
+##load("@rules_cc//cc:defs.bzl", "cc_test")  #load the test target
+
+cc_library(
+    name = "q5_optimizer",
+    srcs = [
+        "q5_optimizer.cc",
+        ],
+    hdrs = [
+        "q5_optimizer.h",
+        ],
+    deps = [
+        "//lib:embedding_lib",
+        "//lib:instruction_lib",
+        "//lib:model_lib",
+    ],
+    linkopts = [
+        "-pthread"
+    ],
+
+	visibility = [
+		"//visibility:public",
+	],
+)
diff --git a/Thread-1/q5_lib/README.md b/Thread-1/q5_lib/README.md
new file mode 100644
index 0000000..31670fb
--- /dev/null
+++ b/Thread-1/q5_lib/README.md
@@ -0,0 +1,7 @@
+# Task 5
+
+This folder contains the code library we build for Thread1:Task5.
+
+Notice that we have already implemented a non in-place updates and in-place recommendations in q4, here we construct a different version that has in-place updates and non in-place recommendations. We argue that this new version should be a little bit faster since recommendations are completed by coping embeddings from embeddingholders. And the experiments support our arguement, though the number of `slow_function` remains unchange, which dominates the total running time.
+
+The main idea here to support non in-place recommendation is that we copy the two embeddingholders `users` and `items` immediately when the `iter_idx` increases. For more details, please refer to files `q5_optimizer.cc` and `q5_optimizer.h` in this folder and `Thread-1/q5.cc`.
diff --git a/Thread-1/q5_lib/q5_optimizer.cc b/Thread-1/q5_lib/q5_optimizer.cc
new file mode 100644
index 0000000..3d4ba92
--- /dev/null
+++ b/Thread-1/q5_lib/q5_optimizer.cc
@@ -0,0 +1,459 @@
+#include <string>
+#include <vector>
+#include <iostream>
+
+#include <thread>
+#include <mutex>
+
+
+
+#include "q5_optimizer.h"
+#include "../lib/embedding.h"
+#include "../lib/instruction.h"
+#include "../lib/model.h"
+
+namespace proj1{
+
+    // Optimizer 
+    Optimizer::Optimizer(std::string users_filename, std::string items_filename,std::string instructions_filename) {
+
+        this->users = new EmbeddingHolder(users_filename);
+        this->items = new EmbeddingHolder(items_filename);
+        this->instructions = read_instructions(instructions_filename);
+
+        this->embedding_length = this->users->get_emb_length();
+
+        int num_init = 0; //count #init instructions
+        this-> max_epoch = 0;
+        this -> instruction_num = this->instructions.size();
+        this -> first_instruction_idx = 0;
+        this -> last_instruction_idx = 0;
+        this -> last_epoch_num = -2;
+        this -> current_epoch_num = -2;//the epch number of init
+        //count #init instructions, max_epoch
+        for (Instruction inst: this -> instructions) {
+            int epoch = 0;
+            if (inst.order == INIT_EMB) {
+                num_init ++;
+            } else {
+                if (inst.order == UPDATE_EMB) {
+                    if (inst.payloads.size() > 3){
+                        epoch = inst.payloads[3];
+                    } else {
+                        epoch = 0;
+                    }
+                } else { // recommend
+                    epoch = inst.payloads[1];
+                }
+            }
+            if (epoch > this->max_epoch) this->max_epoch = epoch;
+        }
+        this -> num_original_users = this-> users->get_n_embeddings();
+        this -> num_users = this -> num_original_users + num_init;
+        this -> num_items = this->items->get_n_embeddings();
+
+        //initialize all new user embeddings
+        //cold starts will be executed later
+        for (int i = 0; i < num_init; i ++){
+            Embedding* new_user = new Embedding(this -> embedding_length);
+            this -> users -> append(new_user);
+        }
+
+        //initialize the metadata
+        this -> thread_status = std::vector<Thread_Status>(this -> instruction_num);
+        for (int i = 0; i < this->instruction_num; i ++) {
+            this -> thread_status[i] = WAITING;
+        }
+
+        this -> users_free = std::vector<bool>(this->num_users);
+        for (int i = 0; i < this -> num_users; i ++) {
+            this -> users_free[i] = true;
+        }
+
+        this -> items_free = std::vector<bool>(this->num_items);
+        for (int i = 0; i < this -> num_items; i ++) {
+            this -> items_free[i] = true;
+        }
+
+        this -> current_instruction_order = INIT_EMB;
+
+        this -> store_snapshot();
+    }
+
+    void Optimizer::sort_instructions() {
+        Instruction temp(" ");
+        bool changed = true;
+        while (changed) {
+            changed = false;
+            for(int i = 0; i < this -> instruction_num -1; i ++) {
+                if (! compare_instructions(this -> instructions[i],this -> instructions[i+1])){
+                    temp = this -> instructions[i];
+                    this -> instructions[i] = this -> instructions[i+1];
+                    this -> instructions[i+1] = temp;
+                    changed = true;
+                }
+            }
+        }
+    }
+
+    int Optimizer::get_epoch_num (int instruction_idx) {
+        InstructionOrder order = this -> instructions[instruction_idx].order;
+        switch (order) {
+            case RECOMMEND: {
+                return this -> instructions[instruction_idx].payloads[1];
+            }
+            case UPDATE_EMB: {
+                Instruction inst = this -> instructions[instruction_idx];
+                if (inst.payloads.size()>3) {
+                    return inst.payloads[3];
+                } else {
+                    return 0;
+                }
+            }
+            case INIT_EMB: {
+                return -2;
+            }
+        }
+        return 0;
+    }
+
+    void Optimizer::store_snapshot() {
+        this -> old_users = copy_holder(this->users);
+        this -> old_items = copy_holder(this->items);
+        this -> last_epoch_num = this -> current_epoch_num;
+        return ;
+    }
+
+    void Optimizer::execute_all() {
+        if (this -> instruction_num == 0) return ;
+        //start executing instruction blocks of the same type
+        this -> sort_instructions();
+        this -> first_instruction_idx = 0;
+        this -> last_instruction_idx = 0;
+        while (this -> first_instruction_idx < this -> instruction_num) {
+            this -> current_instruction_order = this -> instructions[this -> first_instruction_idx].order;
+            this -> last_instruction_idx = this -> first_instruction_idx;
+            this -> current_epoch_num = this -> get_epoch_num(this -> first_instruction_idx);
+            if (this -> current_epoch_num == this -> last_epoch_num + 1) {
+                this -> store_snapshot();
+            }
+            // dispatch subsequent instructions with both order and epoch equal to the current instructuon
+            while(this -> instructions[this->last_instruction_idx].order == this -> current_instruction_order &&
+                    this -> last_instruction_idx < this -> instruction_num &&
+                    this -> get_epoch_num(this -> last_instruction_idx) == this -> current_epoch_num) {
+                this -> last_instruction_idx ++ ;
+            }
+            this -> dispatch_instructions();
+            this -> first_instruction_idx = this -> last_instruction_idx;
+        }
+    }
+
+    void Optimizer::dispatch_instructions() {
+        this -> mux.lock();
+        if (this -> all_terminated()) {
+            this -> mux.unlock();
+            return;
+        }
+        std::vector<int> instruction_idx_list = this -> find_instructions();
+        std::vector<std::thread> thread_list;
+        for(unsigned int i = 0; i < instruction_idx_list.size(); i ++) {
+            thread_list.push_back(std::thread(&Optimizer::single_thread, this, instruction_idx_list[i]));
+            this -> thread_status[instruction_idx_list[i]] = RUNNING;
+        }
+        this->mux.unlock();
+        for(unsigned int i = 0; i < instruction_idx_list.size(); i ++) {
+            thread_list[i].join();
+        }
+
+    }
+
+    void Optimizer::single_thread(int instruction_idx) {
+        this -> execute_one_instruction(instruction_idx);
+        this -> release_resource(instruction_idx);
+        this -> dispatch_instructions();
+    };
+
+    void Optimizer::execute_one_instruction(int idx) {
+        Instruction inst = this -> instructions[idx];
+        
+        switch(inst.order) {
+            case INIT_EMB: {
+                int user_idx = this -> num_original_users + idx;
+                Embedding new_user = *this -> users -> get_embedding(user_idx);
+                Init init_optim (new_user);
+                for (int item_index: inst.payloads) {
+                    init_optim.add_item(this -> items -> get_embedding(item_index));
+                }
+                init_optim.compute();
+                EmbeddingGradient gradient = init_optim.output_grad();
+                this -> users -> update_embedding(user_idx, &gradient, 0.01);
+                break;
+                
+                /* linear version
+                int user_idx = this -> num_original_users + idx;
+                for (int item_index: inst.payloads) {
+                    Embedding* item_emb = this -> items->get_embedding(item_index);
+                    // Call cold start for downstream applications, slow
+                    //Embedding* item = this -> items -> get_embedding(user_idx);
+                    EmbeddingGradient* gradient = cold_start(this -> items -> get_embedding(item_index), item_emb);
+                    this -> users->update_embedding(user_idx, gradient, 0.01);
+                    delete gradient;
+                }
+                break;*/
+                
+            }
+            case UPDATE_EMB: {
+                int user_idx = inst.payloads[0];
+                int item_idx = inst.payloads[1];
+                int label = inst.payloads[2];
+                Embedding* user = this -> users -> get_embedding(user_idx);
+                Embedding* item = this -> items -> get_embedding(item_idx);
+                Update update_optim(user,item,label);
+                update_optim.compute();
+
+                EmbeddingGradient grad1 = update_optim.output_grad1();
+                EmbeddingGradient grad2 = update_optim.output_grad2();
+
+                this -> users->update_embedding(user_idx,&grad1,0.01);
+                this -> items->update_embedding(item_idx,&grad2,0.001);
+                break;
+            }
+            case RECOMMEND: {
+                int user_idx = inst.payloads[0];
+                // Embedding* user = this->users->get_embedding(user_idx);
+                Embedding* user = &(this->old_users)[user_idx];
+                std::vector<Embedding*> item_pool;
+                for (unsigned int i = 2; i < inst.payloads.size(); ++i) {
+                    int item_idx = inst.payloads[i];
+                    // item_pool.push_back(this->items->get_embedding(item_idx));
+                    item_pool.push_back(&(this->old_items)[item_idx]);
+                }
+                Embedding* recommendation = recommend(user, item_pool);
+                this -> mux.lock();
+                recommendation->write_to_stdout();
+                this -> mux.unlock();
+                break;
+            }
+
+        }
+    }
+
+    void Optimizer::release_resource(int instruction_idx) {
+        InstructionOrder order = this -> instructions[instruction_idx].order;
+        this -> mux.lock();
+        switch (order) {
+            case RECOMMEND:{
+                this -> thread_status[instruction_idx] = TERMINATED;
+                break;
+            }
+            case INIT_EMB: {
+                this -> thread_status[instruction_idx] = TERMINATED;
+                int user_involved = this -> user_involved(instruction_idx);
+                this -> users_free[user_involved] = true;
+                break;
+            }
+            case UPDATE_EMB: {
+                this -> thread_status[instruction_idx] = TERMINATED;
+                int user_involved = this -> user_involved(instruction_idx);
+                this -> users_free[user_involved] = true;
+                std::vector<int> items_involved = this -> items_involved(instruction_idx);
+                for (int item_idx : items_involved) {
+                    this -> items_free[item_idx] = true;
+                }
+                break;
+            }
+        }
+
+        this -> mux.unlock();
+    }
+
+    std::vector<int> Optimizer::find_instructions() {
+        std::vector<int> instruction_list;
+        int first = this -> first_instruction_idx;
+        int last = this -> last_instruction_idx;
+        for (int i = first; i < last; i ++ ) {
+            if (this -> thread_status[i] == WAITING) {
+                switch (this->current_instruction_order) {
+                    case RECOMMEND: {
+                        instruction_list.push_back(i);
+                        break;
+                    }
+                    case INIT_EMB: {
+                        int user_involved = this -> user_involved(i);
+                        if (this -> users_free[user_involved]) {
+                            this -> users_free[user_involved] = false;
+                            instruction_list.push_back(i);
+                        }
+                        break;
+                    }
+                    case UPDATE_EMB: {
+                        int user_involved = this -> user_involved(i);
+                        std::vector<int> items_involved = this -> items_involved(i);
+                        if ( ! this -> users_free[user_involved] ) break;
+                        for (int item : items_involved) {
+                            if( ! this -> items_free[item]) break;
+                        }
+                        this -> users_free[user_involved] = false;
+                        for (int item : items_involved) {
+                            this -> items_free[item] = false;
+                        }
+                        instruction_list.push_back(i);
+                        break;
+                    }
+
+                }
+                
+            }
+        }
+        return instruction_list;
+
+    };
+
+    int Optimizer::user_involved(int instruction_idx){
+        Instruction inst = this -> instructions[instruction_idx];
+        if (inst.order == INIT_EMB) return instruction_idx + this -> num_original_users;
+        else return inst.payloads[0];
+    }
+
+    std::vector<int> Optimizer::items_involved(int instruction_idx){
+        Instruction inst = this -> instructions[instruction_idx];
+        switch( inst.order ) {
+            case INIT_EMB : {
+                return inst.payloads;
+            }
+                
+            case UPDATE_EMB :{
+                int item_idx = inst.payloads[1];
+                return std::vector<int>(1, item_idx);
+            }
+            case RECOMMEND : {
+                std::vector<int> item_pool_idx;
+                for (unsigned int i = 2; i < inst.payloads.size(); ++ i) {
+                    item_pool_idx.push_back(inst.payloads[i]);
+                }
+                return item_pool_idx;
+            }
+            default : return inst.payloads;     
+        }
+    }
+
+    // check whether current dispatched threads are terminated
+    bool Optimizer::all_terminated() {
+        for (int i = this -> first_instruction_idx; i < this->last_instruction_idx; i ++) {
+            if (this -> thread_status[i] != TERMINATED) return false;
+        }
+        return true;
+    }
+
+
+
+    //  Init
+    Init::Init(Embedding newuser) {
+        this -> user = newuser;
+        double* data = new double[this -> user.get_length()];
+        this -> gradient = EmbeddingGradient(this -> user.get_length(),data );
+     }
+
+    void Init::add_item(Embedding* item) {
+        this -> items -> append(item);
+    }
+
+    Embedding Init::output_grad() {
+        return this -> gradient;
+    }
+
+    void Init::compute() {
+        int num_items = this -> items -> get_n_embeddings();
+        std::vector<std::thread> thread_list;
+        for (int i = 0; i < num_items; i ++) {
+            Embedding* item = this -> items -> get_embedding(i);
+            thread_list.push_back(std::thread(&Init::single_thread, this, item));
+        }
+
+        for (int i = 0; i < num_items; i ++) {
+            thread_list[i].join();
+        }
+    }
+
+    void Init::single_thread(Embedding* item) {
+        EmbeddingGradient* grad = cold_start(&this -> user, item);
+        // std::cout<<"grad:"<<std::endl;
+        // grad->write_to_stdout();
+        this -> mux.lock();
+        this -> gradient = this -> gradient + grad;
+        // std::cout<<"gradient:"<<std::endl;
+        // this -> gradient.write_to_stdout();
+        this -> mux.unlock();
+    }
+
+
+
+    // Update
+    Update::Update( Embedding* A, Embedding* B, int label) {
+        this -> A = A;
+        this -> B = B;
+        this -> label = label;
+     }
+
+    void Update::calc1() {
+        this -> grad1 = *calc_gradient(this -> A, this -> B,label);
+    }
+    void Update::calc2() {
+        this -> grad2 = *calc_gradient(this -> B, this -> A,label);
+    }
+
+    void Update::compute() {
+        std::thread th1(&Update::calc1, this);
+        std::thread th2(&Update::calc2, this);
+        th1.join();
+        th2.join();
+    }
+
+    EmbeddingGradient Update::output_grad1() {
+        return this -> grad1;
+    }
+    EmbeddingGradient Update::output_grad2() {
+        return this -> grad2;
+    }
+
+    
+    
+    //A comparison function used for sorting
+    // true: correct order
+    // false: need to switch 
+    bool compare_instructions(Instruction inst1, Instruction inst2) {
+        
+        if (inst1.order == INIT_EMB) {
+            return true;
+        }
+        if (inst2.order == INIT_EMB) {
+            return false;
+        }
+        int epoch1,epoch2;
+        if(inst1.order == UPDATE_EMB) {
+            epoch1 = inst1.payloads[3];
+        } else { // recommend
+            epoch1 = inst1.payloads[1];
+        }
+        if(inst2.order == UPDATE_EMB) {
+            epoch2 = inst2.payloads[3];
+        } else {
+            epoch2 = inst2.payloads[1];
+        }
+        if (epoch1 < epoch2) return true;
+        if (epoch1 > epoch2) return false;
+        if (inst1.order == UPDATE_EMB) return true;
+        if (inst2.order == RECOMMEND) return true;
+        return false;
+    }
+
+    EmbeddingStack copy_holder(EmbeddingHolder* holder) {
+        int embedding_num = holder->get_n_embeddings();
+        EmbeddingStack data = std::vector<Embedding>(embedding_num);
+        for (int i=0 ; i < embedding_num; i++) {
+            data[i] = Embedding(holder->get_embedding(i));
+        }
+        return data;
+    }
+
+} //namespace proj1
\ No newline at end of file
diff --git a/Thread-1/q5_lib/q5_optimizer.h b/Thread-1/q5_lib/q5_optimizer.h
new file mode 100644
index 0000000..819e900
--- /dev/null
+++ b/Thread-1/q5_lib/q5_optimizer.h
@@ -0,0 +1,141 @@
+#ifndef THREAD_SCHEDULER_H_
+#define THREAD_SCHEDULER_H_
+
+#include <string>
+#include <vector>
+#include <mutex>
+#include <stdlib.h>
+
+#include "../lib/embedding.h"
+#include "../lib/instruction.h"
+#include "../lib/model.h"
+
+namespace proj1 {
+
+    using EmbeddingStack = std::vector<Embedding>;
+    
+    enum Thread_Status {
+        WAITING =     0,
+        RUNNING,   // 1
+        TERMINATED // 2
+    };
+
+
+    // A scheduler that optimizes the execution order to run updates and recommendations concurrently
+    class Optimizer {
+        public:
+            Optimizer(std::string users_filename,std::string items_filename, std::string instructions_filename);
+            void sort_instructions();
+            //(init)*(recommand-1)*(update0)*(recommand0)*(update1)*(recommand1)*......
+            //also update max_epoch_num
+            void store_snapshot();
+            void execute_all();
+            //start executing all instructions
+            //Do not write to stdout
+            void execute_one_instruction(int idx);//executing one instruction, not thread safe
+            void dispatch_instructions();
+            void single_thread(int idx);
+
+            std::vector<int> find_instructions();
+            //return the indices of instructions that can be executed concurrently
+            //if recommend, then execute all
+            //if init, only consider user dependencies
+            //if update, consider all dependencies
+
+            int user_involved(int instruction_idx);
+            std::vector<int> items_involved(int instr_idx);
+            bool all_terminated();//num must be locked
+            void release_resource(int instruction_idx);
+
+            int get_epoch_num(int instruction_idx);
+
+            void write_to_stdout() {
+                this -> users -> write_to_stdout();
+                this -> items -> write_to_stdout();
+            };
+
+            void clear(){
+                delete this -> users;
+                delete this -> items;
+            }
+
+        private:
+            EmbeddingHolder* users;
+            EmbeddingHolder* items;
+
+            // store the data of last epoch
+            EmbeddingStack old_users;
+            EmbeddingStack old_items;
+
+            Instructions instructions;
+
+            int embedding_length;
+            int instruction_num;
+            int max_epoch;
+            int num_original_users;
+            int num_users;
+            int num_items;
+
+            //running state
+            int first_instruction_idx; //the smallest index of instructions that needs to run
+            int last_instruction_idx;  //the largest index of instructions that needs to run
+            int last_epoch_num;
+            int current_epoch_num;
+
+            std::mutex mux;//protect the following members
+            /////////////////metadata//////////////////////
+            //std::vector<std::thread>* threads;
+            std::vector<Thread_Status> thread_status;//record number
+            std::vector<bool> users_free;
+            std::vector<bool> items_free;
+            InstructionOrder current_instruction_order;
+            //////////////////////////////////////////////
+
+            //std::condition_variable finished;
+    };
+
+
+    class Init {
+        public:
+            Init(Embedding newuser);
+            //~Init_Optimizer() 
+            
+            void add_item(Embedding*);
+            EmbeddingGradient output_grad();
+            void compute();
+            void single_thread(Embedding* item);//single cold start
+        private:
+            EmbeddingHolder* items =new EmbeddingHolder(*(new EmbeddingMatrix));
+            Embedding user;
+            EmbeddingGradient gradient;
+            std::mutex mux;
+    };
+
+
+    class Update {
+        public:
+            Update(Embedding*, Embedding*, int);
+
+            void compute();
+            EmbeddingGradient output_grad1();
+            EmbeddingGradient output_grad2();
+
+        private:
+            void calc1();
+            void calc2();
+            Embedding* A;
+            Embedding* B;
+            int label;
+            EmbeddingGradient grad1;
+            EmbeddingGradient grad2;
+    };
+
+
+    bool compare_instructions(Instruction, Instruction);
+
+    EmbeddingStack copy_holder(EmbeddingHolder*);
+
+}; // namespace proj1
+
+
+#endif // THREAD_LIB_EMBEDDING_H_
\ No newline at end of file
diff --git a/Thread-1/q5_optimizer_test.cc b/Thread-1/q5_optimizer_test.cc
new file mode 100644
index 0000000..cf5f85b
--- /dev/null
+++ b/Thread-1/q5_optimizer_test.cc
@@ -0,0 +1,71 @@
+#include <gtest/gtest.h>
+#include <vector>
+#include "q5_lib/q5_optimizer.h"
+
+
+std::string s0 = "0 0 1 2 3 4 5 6 7 8";
+std::string s1 = "1 3 5 1";
+std::string s2 = "2 2 -1 4 5 6 3 7 9";
+
+namespace proj1 {
+namespace testing{
+
+class OptimizerTest : public ::testing::Test {
+ protected:
+  void SetUp() override {
+	
+    optim = new Optimizer("data/q3.in","data/q3.in", "data/q3_instruction.tsv");
+	users = new EmbeddingHolder("data/q3.in");
+	items = new EmbeddingHolder("data/q3.in");
+  }
+  Instruction inst0 = Instruction(s0);
+  Instruction inst1 = Instruction(s1);
+  Instruction inst2 = Instruction(s2);
+  Optimizer* optim;
+  EmbeddingHolder* users;
+  EmbeddingHolder* items;
+};
+
+bool compare(EmbeddingStack s, EmbeddingHolder* h){
+	if (s.size() != h->get_n_embeddings()) return false;
+	if (s[0].get_length() != h->get_emb_length()) return false;
+	const int length = s.size();
+	for (int i = 0; i < length; i++){
+		if (!(s[i] == *(h->get_embedding(i)))) return false;
+	}
+	return true;
+}
+
+TEST_F(OptimizerTest, test_compare_instructions){
+	EXPECT_EQ(true, compare_instructions(inst0, inst1));
+	EXPECT_EQ(true, compare_instructions(inst0, inst2));
+	EXPECT_EQ(false, compare_instructions(inst1, inst2));
+}
+
+TEST_F(OptimizerTest, test_get_epoch_num){
+
+	EXPECT_EQ(0, optim->get_epoch_num(0));
+	EXPECT_EQ(0, optim->get_epoch_num(1));
+	EXPECT_EQ(0, optim->get_epoch_num(2));
+	EXPECT_EQ(-2, optim->get_epoch_num(3));
+	EXPECT_EQ(-2, optim->get_epoch_num(4));
+	EXPECT_EQ(0, optim->get_epoch_num(5));
+	EXPECT_EQ(1, optim->get_epoch_num(6));
+	EXPECT_EQ(1, optim->get_epoch_num(7));
+	EXPECT_EQ(-2, optim->get_epoch_num(8));
+}
+
+TEST_F(OptimizerTest, test_copy_holder){
+	EmbeddingStack old_users = copy_holder(users);
+	EmbeddingStack old_items = copy_holder(items);
+	EXPECT_EQ(1, compare(old_users, users));
+	EXPECT_EQ(1, compare(old_items, items));
+}
+
+} // namespace testing
+} // namespace proj1
+
+int main(int argc,char **argv){
+  testing::InitGoogleTest(&argc,argv);
+  return RUN_ALL_TESTS();
+}
diff --git a/Thread-1/scheduler/BUILD b/Thread-1/scheduler/BUILD
new file mode 100644
index 0000000..8fd7f64
--- /dev/null
+++ b/Thread-1/scheduler/BUILD
@@ -0,0 +1,25 @@
+##load("@rules_cc//cc:defs.bzl", "cc_test")  #load the test target
+
+cc_library(
+    name = "scheduler",
+    srcs = [
+        "scheduler.cc",
+        ],
+    hdrs = [
+        "scheduler.h",
+        ],
+    deps = [
+        "//lib:embedding_lib",
+        "//lib:instruction_lib",
+        "//lib:model_lib",
+        "//update_optimizer:update_optimizer",
+        "//init_optimizer:init_optimizer"
+    ],
+    linkopts = [
+        "-pthread"
+    ],
+
+	visibility = [
+		"//visibility:public",
+	],
+)
diff --git a/Thread-1/scheduler/scheduler.cc b/Thread-1/scheduler/scheduler.cc
new file mode 100644
index 0000000..1b75987
--- /dev/null
+++ b/Thread-1/scheduler/scheduler.cc
@@ -0,0 +1,365 @@
+#include <string>
+#include <vector>
+#include <iostream>
+
+#include <thread>
+#include <mutex>
+
+
+
+#include "scheduler.h"
+#include "../lib/embedding.h"
+#include "../lib/instruction.h"
+#include "../lib/model.h"
+#include "../init_optimizer/init_optimizer.h"
+
+#include "../update_optimizer/update_optimizer.h"
+
+namespace proj1{
+    Scheduler::Scheduler(std::string users_filename, std::string items_filename,std::string instructions_filename) {
+
+        this->users = new EmbeddingHolder(users_filename);
+        this->items = new EmbeddingHolder(items_filename);
+        this->instructions = read_instructions(instructions_filename);
+
+        this->embedding_length = this->users->get_emb_length();
+
+        int num_init = 0; //count #init instructions
+        this-> max_epoch = 0;
+        this -> instruction_num = this->instructions.size();
+        this -> first_instruction_idx = 0;
+        this -> last_instruction_idx = 0;
+        this -> current_epoch_num = -2;//the epch number of init
+        //count #init instructions, max_epoch
+        for (Instruction inst: this -> instructions) {
+            int epoch = 0;
+            if (inst.order == INIT_EMB) {
+                num_init ++;
+            } else {
+                if (inst.order == UPDATE_EMB) {
+                    if (inst.payloads.size() > 3){
+                        epoch = inst.payloads[3];
+                    } else {
+                        epoch = 0;
+                    }
+                } else {
+                    epoch = inst.payloads[1];
+                }
+            }
+            if (epoch > this->max_epoch) this->max_epoch = epoch;
+        }
+        this -> num_original_users = this-> users->get_n_embeddings();
+        this -> num_users = this -> num_original_users + num_init;
+        this -> num_items = this->items->get_n_embeddings();
+
+        //initialize all new user embeddings
+        //cold starts will be executed later
+        for (int i = 0; i < num_init; i ++){
+            Embedding* new_user = new Embedding(this -> embedding_length);
+            this -> users -> append(new_user);
+        }
+
+        //initialize the metadata
+        this -> thread_status = std::vector<Thread_Status>(this -> instruction_num);
+        for (int i = 0; i < this->instruction_num; i ++) {
+            this -> thread_status[i] = WAITING;
+        }
+
+        this -> users_free = std::vector<bool>(this->num_users);
+        for (int i = 0; i < this -> num_users; i ++) {
+            this -> users_free[i] = true;
+        }
+
+        this -> items_free = std::vector<bool>(this->num_items);
+        for (int i = 0; i < this -> num_items; i ++) {
+            this -> items_free[i] = true;
+        }
+
+        this -> current_instruction_order = INIT_EMB;
+
+       
+
+        
+    }
+
+    void Scheduler::sort_instructions() {
+        Instruction temp(" ");
+        bool changed = true;
+        while (changed) {
+            changed = false;
+            for(int i = 0; i < this -> instruction_num -1; i ++) {
+                if (! compare_instructions(this -> instructions[i],this -> instructions[i+1])){
+                    temp = this -> instructions[i];
+                    this -> instructions[i] = this -> instructions[i+1];
+                    this -> instructions[i+1] = temp;
+
+                    changed = true;
+                }
+            }
+        }
+    }
+
+    //A comperison function used for sorting
+    bool compare_instructions(Instruction inst1, Instruction inst2) {
+        
+        if (inst1.order == INIT_EMB) {
+            return true;
+        }
+        if (inst2.order == INIT_EMB) {
+            return false;
+        }
+        int epoch1,epoch2;
+        if(inst1.order == UPDATE_EMB) {
+            epoch1 = inst1.payloads[3];
+        } else {
+            epoch1 = inst1.payloads[1];
+        }
+        if(inst2.order == UPDATE_EMB) {
+            epoch2 = inst2.payloads[3];
+        } else {
+            epoch2 = inst2.payloads[1];
+        }
+        if (epoch1 < epoch2)return true;
+        if (epoch1 > epoch2)return false;
+        if (inst1.order ==UPDATE_EMB) return true;
+        if (inst2.order ==RECOMMEND) return true;
+        return false;
+
+    }
+
+
+    void Scheduler::execute_all() {
+        if (this -> instruction_num == 0)return ;
+        //start executing instruction blocks of the same type
+        this -> sort_instructions();
+        this -> first_instruction_idx = 0;
+        this -> last_instruction_idx = 0;
+        while (this -> first_instruction_idx < this -> instruction_num) {
+            this -> current_instruction_order = this -> instructions[this -> first_instruction_idx].order;
+            this -> last_instruction_idx = this -> first_instruction_idx;
+            this -> current_epoch_num = this -> get_epoch_num(this -> first_instruction_idx);
+            while(this -> instructions[this->last_instruction_idx].order == this -> current_instruction_order &&
+                    this -> last_instruction_idx < this -> instruction_num &&
+                    this -> get_epoch_num(this -> last_instruction_idx) == this -> current_epoch_num) {
+                this -> last_instruction_idx ++ ;
+            }
+            this -> dispatch_instructions();
+            this -> first_instruction_idx = this -> last_instruction_idx;
+        }
+    }
+    void Scheduler::execute_one_instruction(int idx) {
+        Instruction inst = this -> instructions[idx];
+        
+        switch(inst.order) {
+        case INIT_EMB: {
+            int user_idx = this -> num_original_users + idx;
+            Embedding new_user = *this -> users -> get_embedding(user_idx);
+            Init_Optimizer optimizer (new_user);
+            for (int item_index: inst.payloads) {
+                optimizer.add_item(this -> items -> get_embedding(item_index));
+            }
+            optimizer.compute();
+            EmbeddingGradient gradient = optimizer.output_grad();
+            this -> users -> update_embedding(user_idx, &gradient, 0.01);
+            break;
+            
+            /* linear version
+            int user_idx = this -> num_original_users + idx;
+            for (int item_index: inst.payloads) {
+                Embedding* item_emb = this -> items->get_embedding(item_index);
+                // Call cold start for downstream applications, slow
+                //Embedding* item = this -> items -> get_embedding(user_idx);
+                EmbeddingGradient* gradient = cold_start(this -> items -> get_embedding(item_index), item_emb);
+                this -> users->update_embedding(user_idx, gradient, 0.01);
+                delete gradient;
+            }
+            break;*/
+            
+        }
+        case UPDATE_EMB: {
+            int user_idx = inst.payloads[0];
+            int item_idx = inst.payloads[1];
+            int label = inst.payloads[2];
+            Embedding user = *this -> users -> get_embedding(user_idx);
+            Embedding item = *this -> items -> get_embedding(item_idx);
+            Update_Optimizer optimizer(user,item,label);
+            optimizer.compute();
+
+            EmbeddingGradient grad1 = optimizer.output_grad1();
+            EmbeddingGradient grad2 = optimizer.output_grad2();
+
+            this -> users->update_embedding(user_idx,&grad1,0.01);
+            this -> items->update_embedding(item_idx,&grad2,0.001);
+            break;
+        }
+        case RECOMMEND: {
+            int user_idx = inst.payloads[0];
+            Embedding* user = this->users->get_embedding(user_idx);
+            std::vector<Embedding*> item_pool;
+            for (unsigned int i = 2; i < inst.payloads.size(); ++i) {
+                int item_idx = inst.payloads[i];
+                item_pool.push_back(this->items->get_embedding(item_idx));
+            }
+            Embedding* recommendation = recommend(user, item_pool);
+            this -> mux.lock();
+            recommendation->write_to_stdout();
+            this -> mux.unlock();
+            break;
+        }
+
+        }
+    }
+   
+
+    void Scheduler::dispatch_instructions() {
+        this -> mux.lock();
+        if (this -> all_terminated()) {
+            this -> mux.unlock();
+            return;
+        }
+        std::vector<int> instruction_idx_list = this -> find_instructions();
+        std::vector<std::thread> thread_list;
+        for(unsigned int i = 0; i < instruction_idx_list.size(); i ++) {
+            thread_list.push_back(std::thread(&Scheduler::single_thread, this, instruction_idx_list[i]));
+            this -> thread_status[instruction_idx_list[i]] = RUNNING;
+        }
+        this->mux.unlock();
+        for(unsigned int i = 0; i < instruction_idx_list.size(); i ++) {
+            thread_list[i].join();
+        }
+
+    }
+    void Scheduler::release_resource(int instruction_idx) {
+        InstructionOrder order = this -> instructions[instruction_idx].order;
+        this -> mux.lock();
+        switch (order) {
+            case RECOMMEND:{
+                this -> thread_status[instruction_idx] = TERMINATED;
+                break;
+            }
+            case INIT_EMB: {
+                this -> thread_status[instruction_idx] = TERMINATED;
+                int user_involved = this -> user_involved(instruction_idx);
+                this -> users_free[user_involved] = true;
+                break;
+            }
+            case UPDATE_EMB: {
+                this -> thread_status[instruction_idx] = TERMINATED;
+                int user_involved = this -> user_involved(instruction_idx);
+                this -> users_free[user_involved] = true;
+                std::vector<int> items_involved = this -> items_involved(instruction_idx);
+                for (int item_idx : items_involved) {
+                    this -> items_free[item_idx] = true;
+                }
+                break;
+            }
+        }
+
+        this -> mux.unlock();
+    }
+
+    int Scheduler::get_epoch_num (int instruction_idx) {
+        InstructionOrder order = this -> instructions[instruction_idx].order;
+        switch (order) {
+            case RECOMMEND: {
+                return this -> instructions[instruction_idx].payloads[1];
+            }
+            case UPDATE_EMB: {
+                Instruction inst = this -> instructions[instruction_idx];
+                if (inst.payloads.size()>3) {
+                    return inst.payloads[3];
+                } else {
+                    return 0;
+                }
+            }
+            case INIT_EMB: {
+                return -2;
+            }
+        }
+        return 0;
+    }
+
+    std::vector<int> Scheduler::find_instructions() {
+        std::vector<int> instruction_list;
+        int first = this -> first_instruction_idx;
+        int last = this -> last_instruction_idx;
+        for (int i = first; i < last; i ++ ) {
+            if (this -> thread_status[i] == WAITING) {
+                switch (this->current_instruction_order) {
+                    case RECOMMEND: {
+                        instruction_list.push_back(i);
+                        break;
+                    }
+                    case INIT_EMB: {
+                        int user_involved = this -> user_involved(i);
+                        if (this -> users_free[user_involved]) {
+                            this -> users_free[user_involved] = false;
+                            instruction_list.push_back(i);
+                        }
+                        break;
+                    }
+                    case UPDATE_EMB: {
+                        int user_involved = this -> user_involved(i);
+                        std::vector<int> items_involved = this -> items_involved(i);
+                        if ( ! this -> users_free[user_involved] ) break;
+                        for (int item : items_involved) {
+                            if( ! this -> items_free[item]) break;
+                        }
+                        this -> users_free[user_involved] = false;
+                        for (int item : items_involved) {
+                            this -> items_free[item] = false;
+                        }
+                        instruction_list.push_back(i);
+                        break;
+                    }
+
+                }
+                
+            }
+        }
+        return instruction_list;
+
+    };
+
+
+    void Scheduler::single_thread(int instruction_idx) {
+        this -> execute_one_instruction(instruction_idx);
+        this -> release_resource(instruction_idx);
+        this -> dispatch_instructions();
+    };
+
+
+    int Scheduler::user_involved(int instruction_idx){
+        Instruction inst = this -> instructions[instruction_idx];
+        if (inst.order == INIT_EMB) return instruction_idx + this -> num_original_users;
+        else return inst.payloads[0];
+    }
+    std::vector<int> Scheduler::items_involved(int instruction_idx){
+        Instruction inst = this -> instructions[instruction_idx];
+        switch( inst.order ) {
+            case INIT_EMB : {
+                return inst.payloads;
+            }
+                
+            case UPDATE_EMB :{
+                int item_idx = inst.payloads[1];
+                return std::vector<int>(1, item_idx);
+            }
+            case RECOMMEND : {
+                std::vector<int> item_pool_idx;
+                for (unsigned int i = 2; i < inst.payloads.size(); ++ i) {
+                    item_pool_idx.push_back(inst.payloads[i]);
+                }
+                return item_pool_idx;
+            }
+            default : return inst.payloads;     
+        }
+    }
+
+    bool Scheduler::all_terminated() {
+        for (int i = this -> first_instruction_idx; i < this->last_instruction_idx; i ++) {
+            if (this -> thread_status[i] != TERMINATED) return false;
+        }
+        return true;
+    }
+}//namespace proj1
\ No newline at end of file
diff --git a/Thread-1/scheduler/scheduler.h b/Thread-1/scheduler/scheduler.h
new file mode 100644
index 0000000..d4a0e2b
--- /dev/null
+++ b/Thread-1/scheduler/scheduler.h
@@ -0,0 +1,89 @@
+#ifndef THREAD_SCHEDULER_H_
+#define THREAD_SCHEDULER_H_
+
+#include <string>
+#include <vector>
+
+//#include <thread>
+#include <mutex>
+//#include <condition_variable>
+
+#include "../lib/embedding.h"
+#include "../lib/instruction.h"
+#include "../lib/model.h"
+
+namespace proj1 {
+    
+    enum Thread_Status {
+        WAITING = 0,
+        RUNNING,
+        TERMINATED
+    };
+    
+
+    class Scheduler {
+        public:
+            Scheduler(std::string users_filename,std::string items_filename, std::string instructions_filename);
+            void sort_instructions();
+            //(init)*(recommand-1)*(update0)*(recommand0)*(update1)*(recommand1)*......
+            //also update max_epoch_num
+            void execute_all();
+            //start executing all instructions
+            //Do not write to stdout
+            void execute_one_instruction(int idx);//executing one instruction, not thread safe
+            void dispatch_instructions();
+            void single_thread(int idx);
+
+            std::vector<int> find_instructions();
+            //return the indices of instructions that can be executed concurrently
+            //if recommend, then execute all
+            //if init, only consider user dependencies
+            //if update, consider all dependencies
+
+            int user_involved(int instruction_idx);
+            std::vector<int> items_involved(int instr_idx);    
+            bool all_terminated();//num must be locked
+            void release_resource(int instruction_idx);
+
+            int get_epoch_num(int instruction_idx);
+
+            void write_to_stdout() {
+                this -> users -> write_to_stdout();
+                this -> items -> write_to_stdout();
+            };
+
+        private:
+            EmbeddingHolder* users;
+            EmbeddingHolder* items;
+            Instructions instructions;
+
+            int embedding_length;
+            int instruction_num;
+            int max_epoch;
+            int num_original_users;
+            int num_users;
+            int num_items;
+
+            //running state
+            int first_instruction_idx;//the smallest index of instructions that needs to run
+            int last_instruction_idx;//the largest index of instructions that needs to run
+            int current_epoch_num;
+
+            std::mutex mux;//protect the following members
+            /////////////////metadata//////////////////////
+            //std::vector<std::thread>* threads;
+            std::vector<Thread_Status> thread_status;//record number
+            std::vector<bool> users_free;
+            std::vector<bool> items_free;
+            InstructionOrder current_instruction_order;
+            //////////////////////////////////////////////
+
+            //std::condition_variable finished;
+            
+
+    };
+bool compare_instructions(Instruction, Instruction);
+};
+
+
+#endif // THREAD_LIB_EMBEDDING_H_
\ No newline at end of file
diff --git a/Thread-1/scheduler_test.cc b/Thread-1/scheduler_test.cc
new file mode 100644
index 0000000..510cea8
--- /dev/null
+++ b/Thread-1/scheduler_test.cc
@@ -0,0 +1,59 @@
+#include <gtest/gtest.h>
+#include <vector>
+#include "scheduler/scheduler.h"
+
+
+std::string s0 = "0 0 1 2 3 4 5 6 7 8";
+std::string s1 = "1 3 5 1";
+std::string s2 = "2 2 -1 4 5 6 3 7 9";
+
+namespace proj1 {
+namespace testing{
+
+class SchedulerTest : public ::testing::Test {
+ protected:
+  void SetUp() override {
+	
+    scheduler = new Scheduler("data/q3.in","data/q3.in", "data/q3_instruction.tsv");
+  }
+  Instruction inst0 = Instruction(s0);
+  Instruction inst1 = Instruction(s1);
+  Instruction inst2 = Instruction(s2);
+  Scheduler* scheduler;
+};
+
+bool compare(Embedding emb1, Embedding emb2){
+	double * tmp1 = emb1.get_data();
+	double * tmp2 = emb2.get_data();
+	for(int i = 0; i<20; i++){
+		if(tmp1[i]!=tmp2[i])return false;
+	}
+	return true;
+}
+
+TEST_F(SchedulerTest, test_compare_instructions){
+	EXPECT_EQ(true, compare_instructions(inst0, inst1));
+	EXPECT_EQ(true, compare_instructions(inst0, inst2));
+	EXPECT_EQ(false, compare_instructions(inst1, inst2));
+}
+
+TEST_F(SchedulerTest, test_get_epoch_num){
+
+	EXPECT_EQ(0, scheduler->get_epoch_num(0));
+	EXPECT_EQ(0, scheduler->get_epoch_num(1));
+	EXPECT_EQ(0, scheduler->get_epoch_num(2));
+	EXPECT_EQ(-2, scheduler->get_epoch_num(3));
+	EXPECT_EQ(-2, scheduler->get_epoch_num(4));
+	EXPECT_EQ(0, scheduler->get_epoch_num(5));
+	EXPECT_EQ(1, scheduler->get_epoch_num(6));
+	EXPECT_EQ(1, scheduler->get_epoch_num(7));
+	EXPECT_EQ(-2, scheduler->get_epoch_num(8));
+}
+
+} // namespace testing
+} // namespace proj1
+
+int main(int argc,char **argv){
+  testing::InitGoogleTest(&argc,argv);
+  return RUN_ALL_TESTS();
+}
diff --git a/Thread-1/update_optimizer/BUILD b/Thread-1/update_optimizer/BUILD
new file mode 100644
index 0000000..aae436b
--- /dev/null
+++ b/Thread-1/update_optimizer/BUILD
@@ -0,0 +1,32 @@
+##load("@rules_cc//cc:defs.bzl", "cc_test")  #load the test target
+
+cc_library(
+    name = "update_optimizer",
+    srcs = [
+        "update_optimizer.cc",
+        ],
+    hdrs = [
+        "update_optimizer.h",
+        ],
+    deps = [
+        "//lib:embedding_lib",
+        "//lib:model_lib"
+    ],
+    linkopts = [
+        "-pthread"
+    ],
+
+	visibility = [
+		"//visibility:public",
+	],
+)
+
+cc_test(
+  name = "update_optimizer_test",
+  size = "small",
+  srcs = ["update_optimizer_test.cc"],
+  deps = [
+      "@gtest//:gtest_main",
+	  ":update_optimizer",
+      ],
+)
diff --git a/Thread-1/update_optimizer/update_optimizer.cc b/Thread-1/update_optimizer/update_optimizer.cc
new file mode 100644
index 0000000..4f494c1
--- /dev/null
+++ b/Thread-1/update_optimizer/update_optimizer.cc
@@ -0,0 +1,38 @@
+#include <thread>
+
+#include "../lib/utils.h"
+#include "../lib/embedding.h"
+
+#include "update_optimizer.h"
+ namespace proj1 {
+     Update_Optimizer::Update_Optimizer( Embedding A, Embedding B, int label) {
+        
+         this -> A = A;
+         this -> B = B;
+         this -> label = label;
+     }
+
+     void Update_Optimizer::calc1() {
+        this -> grad1 = *calc_gradient(&this -> A, &this -> B,label);
+     }
+     void Update_Optimizer::calc2() {
+        this -> grad2 = *calc_gradient(&this -> B, &this -> A,label);
+     }
+
+     void Update_Optimizer::compute() {
+        std::thread th1(&Update_Optimizer::calc1, this);
+        std::thread th2(&Update_Optimizer::calc2, this);
+        th1.join();
+        th2.join();
+     }
+
+    EmbeddingGradient Update_Optimizer::output_grad1() {
+        return this -> grad1;
+    }
+    EmbeddingGradient Update_Optimizer::output_grad2() {
+        return this -> grad2;
+
+    }
+
+     
+ }
\ No newline at end of file
diff --git a/Thread-1/update_optimizer/update_optimizer.h b/Thread-1/update_optimizer/update_optimizer.h
new file mode 100644
index 0000000..79b2dda
--- /dev/null
+++ b/Thread-1/update_optimizer/update_optimizer.h
@@ -0,0 +1,38 @@
+//This package parallelize the UPDATE_EMB instruction execution
+#ifndef THREAD_UPDATE_OPTIMIZER_H_
+#define THREAD_UPDATE_OPTIMIZER_H_
+
+#include "../lib/embedding.h"
+#include "../lib/model.h"
+
+
+
+namespace proj1 {
+    class Update_Optimizer {
+        public:
+            Update_Optimizer(Embedding, Embedding,int);
+            
+            void compute();
+
+
+            
+
+            EmbeddingGradient output_grad1();
+            EmbeddingGradient output_grad2();
+
+        private:
+
+            void calc1();
+            void calc2();
+
+            Embedding A;
+            Embedding B;
+            int label;
+            EmbeddingGradient grad1;
+            EmbeddingGradient grad2;
+    
+    };
+};
+
+
+#endif // THREAD_LIB_EMBEDDING_H_
\ No newline at end of file
diff --git a/Thread-1/update_optimizer/update_optimizer_test.cc b/Thread-1/update_optimizer/update_optimizer_test.cc
new file mode 100644
index 0000000..89f877a
--- /dev/null
+++ b/Thread-1/update_optimizer/update_optimizer_test.cc
@@ -0,0 +1,57 @@
+#include <gtest/gtest.h>
+#include <vector>
+#include "update_optimizer.h"
+
+
+double vecA[20] = {-0.9166718150866153,0.43829227278389205,-0.6129205231425989,0.7738693110376684,-0.04456069156634124,0.8807831166061564,-0.8206278700342509,0.5013513447020947,0.8570578529268591,0.3906799520892723,0.6558968505921785,0.0011654760044317314,0.3008835791217257,-0.15983430198414705,-0.0693333837225647,-0.6526558237637923};
+double vecB[20] = {0.9210598583969818,0.42579710374854174,0.4036360259825613,0.030714658443632636,-0.885772459758438,-0.24727514094877123,0.7355606108008894,0.10546495518591437,-0.8023562184533268,-0.49625645997262624,-0.9207327565798142,-0.5815206606673406,0.9351907452001367,0.3172382122419557,0.003001769800845988,-0.922981014248552};
+
+namespace proj1 {
+namespace testing{
+
+class UpdateOptimizerTest : public ::testing::Test {
+ protected:
+  void SetUp() override {
+    embA = new Embedding(20, vecA);
+	embB = new Embedding(20, vecB);
+	optim0 = new Update_Optimizer(*embA, *embB, 0);
+	optim1 = new Update_Optimizer(*embA, *embB, 1);
+  }
+  Embedding* embA;
+  Embedding* embB;
+  Update_Optimizer* optim0;
+  Update_Optimizer* optim1;
+};
+
+bool compare(Embedding emb1, Embedding emb2){
+	double * tmp1 = emb1.get_data();
+	double * tmp2 = emb2.get_data();
+	for(int i = 0; i<20; i++){
+		if(tmp1[i]!=tmp2[i])return false;
+	}
+	return true;
+}
+
+TEST_F(UpdateOptimizerTest, test_compute_output_grad){
+
+	EmbeddingGradient gradA_B_0 = calc_gradient(embA, embB,0);
+	EmbeddingGradient gradB_A_0 = calc_gradient(embB, embA,0);
+	EmbeddingGradient gradA_B_1 = calc_gradient(embA, embB,1);
+	EmbeddingGradient gradB_A_1 = calc_gradient(embB, embA,1);
+
+	optim0->compute();
+	optim1->compute();
+
+	EXPECT_EQ(true, compare(optim0->output_grad1(), gradA_B_0));
+	EXPECT_EQ(true, compare(optim0->output_grad2(), gradB_A_0));
+	EXPECT_EQ(true, compare(optim1->output_grad1(), gradA_B_1));
+	EXPECT_EQ(true, compare(optim1->output_grad2(), gradB_A_1));
+}
+
+} // namespace testing
+} // namespace proj1
+
+int main(int argc,char **argv){
+  testing::InitGoogleTest(&argc,argv);
+  return RUN_ALL_TESTS();
+}
diff --git a/Thread-2/boat/BUILD b/Thread-2/boat/BUILD
index a213add..8b80f7e 100644
--- a/Thread-2/boat/BUILD
+++ b/Thread-2/boat/BUILD
@@ -1,48 +1,53 @@
-##load("@rules_cc//cc:defs.bzl", "cc_test")  #load the test target
-
-cc_library(
-    name = "boatGrader_lib",
-    srcs = [
-        "boatGrader.cc",
-        ],
-    hdrs = [
-        "boatGrader.h",
-        ],
-	visibility = [
-		"//visibility:public",
-	],
-)
-
-cc_library(
-    name = "boat_lib",
-    srcs = [
-        "boat.cc",
-        ],
-    hdrs = [
-        "boat.h",
-        ],
-	deps = [
-        ":boatGrader_lib"
-    ],
-	visibility = [
-		"//visibility:public",
-	],
-)
-
-cc_binary(
-    name = "main",
-    srcs = [
-        "main.cc"
-            ],
-	deps = [
-        ":boatGrader_lib",
-		":boat_lib"
-    ],
-	copts = [
-        "-O3",
-        "-std=c++11",
-    ],
-	linkopts = [
-        "-pthread",
-    ],
+##load("@rules_cc//cc:defs.bzl", "cc_test")  #load the test target
+
+cc_library(
+    name = "boatGrader_lib",
+    srcs = [
+        "boatGrader.cc",
+        ],
+    hdrs = [
+        "boatGrader.h",
+        ],
+	visibility = [
+		"//visibility:public",
+	],
+    
+)
+
+cc_library(
+    name = "boat_lib",
+    srcs = [
+        "boat.cc",
+        ],
+    hdrs = [
+        "boat.h",
+        ],
+	deps = [
+        ":boatGrader_lib",
+        "//semaphore:semaphore"
+    ],
+	visibility = [
+		"//visibility:public",
+	],
+    linkopts = [
+        "-pthread",
+    ],
+)
+
+cc_binary(
+    name = "main",
+    srcs = [
+        "main.cc"
+            ],
+	deps = [
+        ":boatGrader_lib",
+		":boat_lib"
+    ],
+	copts = [
+        "-O3",
+        "-std=c++11",
+    ],
+	linkopts = [
+        "-pthread",
+    ],
 )
\ No newline at end of file
diff --git a/Thread-2/boat/boat.cc b/Thread-2/boat/boat.cc
index 7acb29b..e915830 100644
--- a/Thread-2/boat/boat.cc
+++ b/Thread-2/boat/boat.cc
@@ -1,14 +1,103 @@
 #include <thread>
-#include <vector>
 #include <unistd.h>
-
 #include "boat.h"
 
 namespace proj2{
-	
-Boat::Boat(){
-}
+void Boat:: begin(int a, int b, BoatGrader *bg){    
+    if (a < 0 || b < 2)return;
+    //creating adults
+    for (int i = 0; i < a; i ++) {
+        std::thread th(&Boat::adult_thread, this, bg);
+        th.detach();
+        bg -> initializeAdult();
+    }
+    //creating children
+    for (int i = 0; i < b; i ++) {
+        std::thread th(&Boat::child_thread, this, bg);
+        th.detach();
+        bg -> initializeChild();
+    }
+    //wait for them to be ready
+    for (int i = 0; i < a + b; i ++) {
+        this -> total_count.P();//count the total number
+    }
+
+    this -> children_on_Oahu.V();//wake up a child as the beginning
+
+    this -> finished.P(); //wait to be informed that all have crossed
+
+}//Boat::begin()
+
+void Boat:: adult_thread(BoatGrader* bg) {
+    
+    this -> num_adults ++;
+    this -> total_count.V();//inform the parent thread
+    this -> adults_on_Oahu.P();//wait in the adults queue
+    //wake up 
+    this -> num_adults --;
+    bg -> AdultRowToMolokai();
+    this -> children_on_Molokai.V();//wake up a child on Molokai
+    return;
+}//Boat:: adult_thread()
+
+void Boat:: child_thread(BoatGrader* bg) {    
+    this -> num_children ++;
+    this -> total_count.V();
+    bool on_Oahu = true;
+    this -> children_on_Oahu.P();//wait in the children queue
+
+    while (true) {
+        //wake up, first observe the situation
+        unsigned int num_children = this -> num_children;
+        unsigned int num_adults = this -> num_adults;
+        //the above two will only be used on Oahu, requirements not violated
+        bool pilot_exists = this -> pilot_exists;
+        //Then, determine the next move
+        unsigned int case_num;
+        if (on_Oahu && num_children >= 2 && !pilot_exists)case_num = 1;
+        else if (on_Oahu && pilot_exists)case_num = 2;
+        else if (on_Oahu && num_children <= 1 && !pilot_exists)case_num = 3;
+        else if (!on_Oahu)case_num = 4;
 
-void Boat:: begin(int a, int b, BoatGrader *bg){
-} 
-}
\ No newline at end of file
+        switch (case_num) {
+            case 1:
+                //become the pilot and wake up a child as passenger
+                this -> num_children --;
+                this -> pilot_exists = true;
+                bg -> ChildRowToMolokai();
+                this -> children_on_Oahu.V();//wake up a child
+                on_Oahu = false;
+                this -> arrive.P();//wait for the passenger to arrive
+                if (num_children == 2 && num_adults == 0) {   
+                    this -> finished.V();
+                    return;
+                }
+                //this child will be awake in the next round
+                break;
+            case 2:
+                //ride along with the pilot
+                this -> num_children --;
+                this -> pilot_exists = false;
+                bg -> ChildRideToMolokai();
+                on_Oahu = false;
+                this -> arrive.V();//inform the pilot that this child has arrived Molokai
+                if (num_children > 1 || num_adults == 0)return ;
+                //no need to stay if one of the above two conditions is met
+                this -> children_on_Molokai.P();//wait on Molokai
+                break;
+            case 3:
+                //wake up an adult, then sleep
+                this -> adults_on_Oahu.V();
+                this -> children_on_Oahu.P();
+                break;
+            case 4:
+                //on molokai, row back to Oahu
+                bg -> ChildRowToOahu();
+                this -> num_children ++;
+                on_Oahu = true;
+                //this child will be awake in the next round
+                break;
+        }//switch
+    }//while
+}//Boat::child_thread
+}//namespace proj2
\ No newline at end of file
diff --git a/Thread-2/boat/boat.h b/Thread-2/boat/boat.h
index efa1462..4343775 100644
--- a/Thread-2/boat/boat.h
+++ b/Thread-2/boat/boat.h
@@ -2,18 +2,34 @@
 #define BOAT_H_
 
 #include<stdio.h>
-#include <thread>
-#include <mutex>
 #include <unistd.h>
 
+#include "atomic"
 #include "boatGrader.h"
+#include "semaphore/semaphore.h"
 
 namespace proj2{
 class Boat{
 public:
-	Boat();
+	Boat(){};
     ~Boat(){};
 	void begin(int, int, BoatGrader*);
+
+	void child_thread(BoatGrader*);
+	void adult_thread(BoatGrader*);
+private:
+	//BoatGrader* bg;
+	Semaphore adults_on_Oahu;//waiting queue
+	Semaphore children_on_Oahu;
+	Semaphore children_on_Molokai;
+	Semaphore arrive;//pilot wait for passenger to arrive Molokai before it rows back
+	Semaphore total_count;//used to inform the parent thread that all new threads are ready
+	Semaphore finished;//used to inform the parent thread that all threads are finished
+
+	std::atomic_int num_children;//on Oahu
+	std::atomic_int num_adults;//on Oahu
+
+	bool pilot_exists = false;
 };
 }
 
diff --git a/Thread-2/boat/boatGrader.cc b/Thread-2/boat/boatGrader.cc
index a662361..c9c33bb 100644
--- a/Thread-2/boat/boatGrader.cc
+++ b/Thread-2/boat/boatGrader.cc
@@ -1,124 +1,124 @@
-#include<string>
-
-#include "boatGrader.h" 
-
-namespace proj2 {
-	BoatGrader::BoatGrader(int i, int j){
-		boatAssert(j >=2, "invalid children num", CONDITION_MISMATCH);
-    	childrenInit = j;
-    	adultInit=i;
-        children_on_oahu = j;
-        adults_on_oahu = i;
-        children_on_molokai = 0;
-        adults_on_molokai = 0;
-        passenger_spaces = 1;
-        passenger_to_oahu = 1;
-        boat_on_oahu = true;
-        error_occured = false;
-    }
-    void BoatGrader:: initializeChild(){
-		printf("A child has been created.\n");
-	}
-	
-	//NEW ADDITION FOR 2014
-	void BoatGrader:: initializeAdult(){
-		printf("An adult has been created.\n");
-	}
-
-    /* ChildRowToMolokai should be called when a child pilots the boat
-       from Oahu to Molokai */
-    void BoatGrader:: ChildRowToMolokai() {
-        boatAssert(children_on_oahu > 0 && boat_on_oahu && childrenInit > 0, "wrong Child rowing to Molokai.\n", CONDITION_MISMATCH);
-        children_on_oahu--;
-        children_on_molokai++;
-        passenger_spaces++;
-        boat_on_oahu = false;
-		printf("**Child rowing to Molokai.\n");
-    }
-
-    /* ChildRowToOahu should be called when a child pilots the boat
-       from Molokai to Oahu*/
-    void BoatGrader:: ChildRowToOahu() {
-    	boatAssert(children_on_molokai > 0 && !boat_on_oahu && childrenInit > 0, "wrong Child rowing to Oahu.\n", CONDITION_MISMATCH);
-        children_on_molokai--;
-        children_on_oahu++;
-        passenger_to_oahu++;
-        boat_on_oahu = true;
-		printf("**Child rowing to Oahu.\n");
-    }
-
-    /* ChildRideToMolokai should be called when a child not piloting
-       the boat disembarks on Molokai */
-    void BoatGrader:: ChildRideToMolokai() {
-    	boatAssert(children_on_oahu > 0 && passenger_spaces > 0 && childrenInit > 0, "wrong Child arrived on Molokai as a passenger.\n", CONDITION_MISMATCH);
-        children_on_oahu--;
-        children_on_molokai++;
-        passenger_spaces--;
-		printf("**Child arrived on Molokai as a passenger.\n");
-    }
-
-    /* ChildRideToOahu should be called when a child not piloting
-       the boat disembarks on Oahu */
-    void BoatGrader:: ChildRideToOahu() {
-    	boatAssert(children_on_molokai > 0 && passenger_to_oahu > 0 && childrenInit > 0, "wrong Child arrived on Oahu as a passenger.\n", CONDITION_MISMATCH);
-        children_on_molokai--;
-        children_on_oahu++;
-        passenger_to_oahu--;
-		printf("**Child arrived on Oahu as a passenger.\n");
-    }
-
-    /* AdultRowToMolokai should be called when a adult pilots the boat
-       from Oahu to Molokai */
-    void BoatGrader:: AdultRowToMolokai() {
-    	boatAssert(adults_on_oahu > 0 && boat_on_oahu && adultInit > 0, "wrong Adult rowing to Molokai.\n", CONDITION_MISMATCH);
-        adults_on_oahu--;
-        adults_on_molokai++;
-        boat_on_oahu = false;
-		printf("**Adult rowing to Molokai.\n");
-    }
-
-    /* AdultRowToOahu should be called when a adult pilots the boat
-       from Molokai to Oahu */
-    void BoatGrader:: AdultRowToOahu() {
-    	boatAssert(adults_on_molokai > 0 && !boat_on_oahu && adultInit > 0, "wrong Adult rowing to Oahu.\n", CONDITION_MISMATCH);
-        adults_on_oahu++;
-        adults_on_molokai--;
-        boat_on_oahu = true;
-		printf("**Adult rowing to Oahu.\n");
-    }
-
-    /* AdultRideToMolokai should be called when an adult not piloting
-       the boat disembarks on Molokai */
-    void BoatGrader:: AdultRideToMolokai() {
-    	boatAssert(false, "adult can not ride as passenger", ADULT_RIDE);
-        error_occured = true;
-		printf("**Adult arrived on Molokai as a passenger.\n");
-    }
-
-    /* AdultRideToOahu should be called when an adult not piloting
-       the boat disembarks on Oahu */
-    void BoatGrader:: AdultRideToOahu() {
-    	boatAssert(false, "adult can not ride as passenger", ADULT_RIDE);
-        error_occured = true;
-		printf("**Adult arrived on Oahu as a passenger.\n");
-    }
-    
-
-    int BoatGrader::adultsLeft() {
-        return adults_on_oahu;
-    }
-
-    int BoatGrader::childrenLeft() {
-        return children_on_oahu;
-    }
-
-    bool BoatGrader:: passed() {
-        return children_on_oahu == 0 && adults_on_oahu == 0;
-    }
-
-    int BoatGrader::points() {
-        if(error_occured)
-            return 0;
-        return children_on_oahu != 0 || adults_on_oahu != 0 ? 1 : 2;
-    }
-}
+#include<string>
+
+#include "boatGrader.h" 
+
+namespace proj2 {
+	BoatGrader::BoatGrader(int i, int j){
+		boatAssert(j >=2, "invalid children num", CONDITION_MISMATCH);
+    	childrenInit = j;
+    	adultInit=i;
+        children_on_oahu = j;
+        adults_on_oahu = i;
+        children_on_molokai = 0;
+        adults_on_molokai = 0;
+        passenger_spaces = 1;
+        passenger_to_oahu = 1;
+        boat_on_oahu = true;
+        error_occured = false;
+    }
+    void BoatGrader:: initializeChild(){
+		printf("A child has been created.\n");
+	}
+	
+	//NEW ADDITION FOR 2014
+	void BoatGrader:: initializeAdult(){
+		printf("An adult has been created.\n");
+	}
+
+    /* ChildRowToMolokai should be called when a child pilots the boat
+       from Oahu to Molokai */
+    void BoatGrader:: ChildRowToMolokai() {
+        boatAssert(children_on_oahu > 0 && boat_on_oahu && childrenInit > 0, "wrong Child rowing to Molokai.\n", CONDITION_MISMATCH);
+        children_on_oahu--;
+        children_on_molokai++;
+        passenger_spaces++;
+        boat_on_oahu = false;
+		printf("**Child rowing to Molokai.\n");
+    }
+
+    /* ChildRowToOahu should be called when a child pilots the boat
+       from Molokai to Oahu*/
+    void BoatGrader:: ChildRowToOahu() {
+    	boatAssert(children_on_molokai > 0 && !boat_on_oahu && childrenInit > 0, "wrong Child rowing to Oahu.\n", CONDITION_MISMATCH);
+        children_on_molokai--;
+        children_on_oahu++;
+        passenger_to_oahu++;
+        boat_on_oahu = true;
+		printf("**Child rowing to Oahu.\n");
+    }
+
+    /* ChildRideToMolokai should be called when a child not piloting
+       the boat disembarks on Molokai */
+    void BoatGrader:: ChildRideToMolokai() {
+    	boatAssert(children_on_oahu > 0 && passenger_spaces > 0 && childrenInit > 0, "wrong Child arrived on Molokai as a passenger.\n", CONDITION_MISMATCH);
+        children_on_oahu--;
+        children_on_molokai++;
+        passenger_spaces--;
+		printf("**Child arrived on Molokai as a passenger.\n");
+    }
+
+    /* ChildRideToOahu should be called when a child not piloting
+       the boat disembarks on Oahu */
+    void BoatGrader:: ChildRideToOahu() {
+    	boatAssert(children_on_molokai > 0 && passenger_to_oahu > 0 && childrenInit > 0, "wrong Child arrived on Oahu as a passenger.\n", CONDITION_MISMATCH);
+        children_on_molokai--;
+        children_on_oahu++;
+        passenger_to_oahu--;
+		printf("**Child arrived on Oahu as a passenger.\n");
+    }
+
+    /* AdultRowToMolokai should be called when a adult pilots the boat
+       from Oahu to Molokai */
+    void BoatGrader:: AdultRowToMolokai() {
+    	boatAssert(adults_on_oahu > 0 && boat_on_oahu && adultInit > 0, "wrong Adult rowing to Molokai.\n", CONDITION_MISMATCH);
+        adults_on_oahu--;
+        adults_on_molokai++;
+        boat_on_oahu = false;
+		printf("**Adult rowing to Molokai.\n");
+    }
+
+    /* AdultRowToOahu should be called when a adult pilots the boat
+       from Molokai to Oahu */
+    void BoatGrader:: AdultRowToOahu() {
+    	boatAssert(adults_on_molokai > 0 && !boat_on_oahu && adultInit > 0, "wrong Adult rowing to Oahu.\n", CONDITION_MISMATCH);
+        adults_on_oahu++;
+        adults_on_molokai--;
+        boat_on_oahu = true;
+		printf("**Adult rowing to Oahu.\n");
+    }
+
+    /* AdultRideToMolokai should be called when an adult not piloting
+       the boat disembarks on Molokai */
+    void BoatGrader:: AdultRideToMolokai() {
+    	boatAssert(false, "adult can not ride as passenger", ADULT_RIDE);
+        error_occured = true;
+		printf("**Adult arrived on Molokai as a passenger.\n");
+    }
+
+    /* AdultRideToOahu should be called when an adult not piloting
+       the boat disembarks on Oahu */
+    void BoatGrader:: AdultRideToOahu() {
+    	boatAssert(false, "adult can not ride as passenger", ADULT_RIDE);
+        error_occured = true;
+		printf("**Adult arrived on Oahu as a passenger.\n");
+    }
+    
+
+    int BoatGrader::adultsLeft() {
+        return adults_on_oahu;
+    }
+
+    int BoatGrader::childrenLeft() {
+        return children_on_oahu;
+    }
+
+    bool BoatGrader:: passed() {
+        return children_on_oahu == 0 && adults_on_oahu == 0;
+    }
+
+    int BoatGrader::points() {
+        if(error_occured)
+            return 0;
+        return children_on_oahu != 0 || adults_on_oahu != 0 ? 1 : 2;
+    }
+}
diff --git a/Thread-2/boat/boatGrader.h b/Thread-2/boat/boatGrader.h
index fc14f71..97e28aa 100644
--- a/Thread-2/boat/boatGrader.h
+++ b/Thread-2/boat/boatGrader.h
@@ -1,104 +1,104 @@
-#ifndef BOAT_GRADER_H_
-#define BOAT_GRADER_H_
-
-#include<stdio.h>
-#include <iostream>
-
-
-namespace proj2 {
-	
-enum BOAT_ERROR {
-    CONDITION_MISMATCH = 0,
-    ADULT_RIDE = 1,
-    WRONG_ANSWER = 2
-};	
-
-class BoatGrader {
-
-    /**
-     * BoatGrader consists of functions to be called to show that
-     * your solution is properly synchronized. This version simply
-     * prints messages to standard out, so that you can watch it.
-     * You cannot submit this file, as we will be using our own
-     * version of it during grading.
-
-     * Note that this file includes all possible variants of how
-     * someone can get from one island to another. Inclusion in
-     * this class does not imply that any of the indicated actions
-     * are a good idea or even allowed.
-     */
-public:
-     
-    template <class T>
-	inline void boatAssert(bool condition, char const *msg, T error) {
-	    if (!condition) {
-	        std::cerr << msg << std::endl;
-	        error_occured = true;
-	        throw error;
-	    }
-	}
-	
-	BoatGrader(int i, int j);
-   ~BoatGrader(){};
-	
-	void initializeChild();
-	
-	void initializeAdult();
-
-    /* ChildRowToMolokai should be called when a child pilots the boat
-       from Oahu to Molokai */
-    void ChildRowToMolokai() ;
-
-    /* ChildRowToOahu should be called when a child pilots the boat
-       from Molokai to Oahu*/
-    void ChildRowToOahu();
-
-    /* ChildRideToMolokai should be called when a child not piloting
-       the boat disembarks on Molokai */
-    void ChildRideToMolokai() ;
-
-    /* ChildRideToOahu should be called when a child not piloting
-       the boat disembarks on Oahu */
-    void ChildRideToOahu() ;
-
-    /* AdultRowToMolokai should be called when a adult pilots the boat
-       from Oahu to Molokai */
-    void AdultRowToMolokai() ;
-
-    /* AdultRowToOahu should be called when a adult pilots the boat
-       from Molokai to Oahu */
-    void AdultRowToOahu() ;
-
-    /* AdultRideToMolokai should be called when an adult not piloting
-       the boat disembarks on Molokai */
-    void AdultRideToMolokai() ;
-
-    /* AdultRideToOahu should be called when an adult not piloting
-       the boat disembarks on Oahu */
-    void AdultRideToOahu() ;
-    
-    int adultsLeft();
-    
-    int childrenLeft();
-    
-    bool passed();
-    
-    int points();
-    
-private:
-	int childrenInit;
-	int adultInit;
-    int children_on_oahu;
-    int adults_on_oahu;
-    int children_on_molokai;
-    int adults_on_molokai;
-    int passenger_spaces;
-    int passenger_to_oahu;
-    bool boat_on_oahu;
-    bool error_occured;
-    
-    
-};
-
-}
-#endif // BOAT_GRADER_H_
+#ifndef BOAT_GRADER_H_
+#define BOAT_GRADER_H_
+
+#include<stdio.h>
+#include <iostream>
+
+
+namespace proj2 {
+	
+enum BOAT_ERROR {
+    CONDITION_MISMATCH = 0,
+    ADULT_RIDE = 1,
+    WRONG_ANSWER = 2
+};	
+
+class BoatGrader {
+
+    /**
+     * BoatGrader consists of functions to be called to show that
+     * your solution is properly synchronized. This version simply
+     * prints messages to standard out, so that you can watch it.
+     * You cannot submit this file, as we will be using our own
+     * version of it during grading.
+
+     * Note that this file includes all possible variants of how
+     * someone can get from one island to another. Inclusion in
+     * this class does not imply that any of the indicated actions
+     * are a good idea or even allowed.
+     */
+public:
+     
+    template <class T>
+	inline void boatAssert(bool condition, char const *msg, T error) {
+	    if (!condition) {
+	        std::cerr << msg << std::endl;
+	        error_occured = true;
+	        throw error;
+	    }
+	}
+	
+	BoatGrader(int i, int j);
+   ~BoatGrader(){};
+	
+	void initializeChild();
+	
+	void initializeAdult();
+
+    /* ChildRowToMolokai should be called when a child pilots the boat
+       from Oahu to Molokai */
+    void ChildRowToMolokai() ;
+
+    /* ChildRowToOahu should be called when a child pilots the boat
+       from Molokai to Oahu*/
+    void ChildRowToOahu();
+
+    /* ChildRideToMolokai should be called when a child not piloting
+       the boat disembarks on Molokai */
+    void ChildRideToMolokai() ;
+
+    /* ChildRideToOahu should be called when a child not piloting
+       the boat disembarks on Oahu */
+    void ChildRideToOahu() ;
+
+    /* AdultRowToMolokai should be called when a adult pilots the boat
+       from Oahu to Molokai */
+    void AdultRowToMolokai() ;
+
+    /* AdultRowToOahu should be called when a adult pilots the boat
+       from Molokai to Oahu */
+    void AdultRowToOahu() ;
+
+    /* AdultRideToMolokai should be called when an adult not piloting
+       the boat disembarks on Molokai */
+    void AdultRideToMolokai() ;
+
+    /* AdultRideToOahu should be called when an adult not piloting
+       the boat disembarks on Oahu */
+    void AdultRideToOahu() ;
+    
+    int adultsLeft();
+    
+    int childrenLeft();
+    
+    bool passed();
+    
+    int points();
+    
+private:
+	int childrenInit;
+	int adultInit;
+    int children_on_oahu;
+    int adults_on_oahu;
+    int children_on_molokai;
+    int adults_on_molokai;
+    int passenger_spaces;
+    int passenger_to_oahu;
+    bool boat_on_oahu;
+    bool error_occured;
+    
+    
+};
+
+}
+#endif // BOAT_GRADER_H_
diff --git a/Thread-2/boat/main.cc b/Thread-2/boat/main.cc
index e049b73..410b1fd 100644
--- a/Thread-2/boat/main.cc
+++ b/Thread-2/boat/main.cc
@@ -1,26 +1,26 @@
-#include<stdio.h>
-#include<string>
-
-#include "boat.h"
-#include "boatGrader.h"
-
-int main(int argc, char *argv[]){
-	if (argc < 3){
-        printf("\nUsage %s [adult num] [children num] \n", argv[0]);
-        exit(1);
-    }
-    int adults = atoi(argv[1]);
-    int children = atoi(argv[2]);
-	proj2::BoatGrader* bg = new proj2::BoatGrader(adults,children); 
-	proj2::Boat* boat = new proj2::Boat();
-	boat->begin(adults,children, bg);
-	int k = bg->childrenLeft();
-	bg->boatAssert(k == 0, "Left children on oahu", proj2::WRONG_ANSWER);
-	int l = bg->adultsLeft();
-	bg->boatAssert(l == 0, "Left adults on oahu", proj2::WRONG_ANSWER);
-	printf("pass the test!\n");
-	delete bg;
-	delete boat;
-	return 0;
-}
-
+#include<stdio.h>
+#include<string>
+
+#include "boat.h"
+#include "boatGrader.h"
+
+int main(int argc, char *argv[]){
+	if (argc < 3){
+        printf("\nUsage %s [adult num] [children num] \n", argv[0]);
+        exit(1);
+    }
+    int adults = atoi(argv[1]);
+    int children = atoi(argv[2]);
+	proj2::BoatGrader* bg = new proj2::BoatGrader(adults,children); 
+	proj2::Boat* boat = new proj2::Boat();
+	boat->begin(adults,children, bg);
+	int k = bg->childrenLeft();
+	bg->boatAssert(k == 0, "Left children on oahu", proj2::WRONG_ANSWER);
+	int l = bg->adultsLeft();
+	bg->boatAssert(l == 0, "Left adults on oahu", proj2::WRONG_ANSWER);
+	printf("pass the test!\n");
+	delete bg;
+	delete boat;
+	return 0;
+}
+
diff --git a/Thread-2/boat/semaphore/BUILD b/Thread-2/boat/semaphore/BUILD
new file mode 100644
index 0000000..fa3cd4c
--- /dev/null
+++ b/Thread-2/boat/semaphore/BUILD
@@ -0,0 +1,19 @@
+cc_library(
+    name = "semaphore",
+    srcs = [
+        "semaphore.cc",
+        ],
+    hdrs = [
+        "semaphore.h",
+        ],
+	visibility = [
+		"//visibility:public",
+	],
+    copts = [
+        "-O3",
+        "-std=c++11",
+    ],
+	linkopts = [
+        "-pthread",
+    ],
+)
\ No newline at end of file
diff --git a/Thread-2/boat/semaphore/semaphore.cc b/Thread-2/boat/semaphore/semaphore.cc
new file mode 100644
index 0000000..7418c34
--- /dev/null
+++ b/Thread-2/boat/semaphore/semaphore.cc
@@ -0,0 +1,17 @@
+#include "semaphore.h"
+
+namespace proj2 {
+    void Semaphore::P() {
+        std::unique_lock<std::mutex> loc(this -> m);
+        if (--count < 0) {
+            cv.wait(loc);
+        }
+    }
+    void Semaphore::V() {
+        std::unique_lock<std::mutex> loc(this -> m);
+        if (++count <= 0) {
+            cv.notify_one();
+        }
+    }
+
+}//proj2
\ No newline at end of file
diff --git a/Thread-2/boat/semaphore/semaphore.h b/Thread-2/boat/semaphore/semaphore.h
new file mode 100644
index 0000000..8d876cb
--- /dev/null
+++ b/Thread-2/boat/semaphore/semaphore.h
@@ -0,0 +1,21 @@
+#ifndef SEMAPHORE_H_
+#define SEMAPHORE_H_
+
+
+#include <condition_variable>
+#include <mutex>
+
+namespace proj2{
+class Semaphore{
+private:
+    int count;
+    std::mutex m;
+    std::condition_variable cv;
+public:
+    Semaphore(int init = 0):count(init){}
+    void P();
+    void V();	
+};
+}//proj2
+
+#endif // SEMAPHORE_H_
diff --git a/Thread-2/deadlock/BUILD b/Thread-2/deadlock/BUILD
index 2d867c5..8c874ff 100644
--- a/Thread-2/deadlock/BUILD
+++ b/Thread-2/deadlock/BUILD
@@ -16,5 +16,10 @@ cc_binary(
     ],
     linkopts = [
         "-pthread",
-    ]
+    ],
+    data = [
+        "data/example.in",
+        "data/trivial.in",
+        "data/test.in"
+    ],
 )
\ No newline at end of file
diff --git a/Thread-2/deadlock/data/test.in b/Thread-2/deadlock/data/test.in
new file mode 100644
index 0000000..38412a1
--- /dev/null
+++ b/Thread-2/deadlock/data/test.in
@@ -0,0 +1,101 @@
+10 10 10 10
+0 3 6 5 1 1 1
+2 0 1 2 2 4 1
+2 1 1 3 5 2 1
+2 0 4 3 2 5 1
+3 1 7 3 4 3 1
+3 0 5 1 4 3 1
+2 3 1 7 3 5 1
+3 1 3 7 2 2 1
+0 1 3 6 3 3 1
+1 0 4 4 5 5 1
+3 1 7 10 2 5 1
+1 2 5 2 4 1 1
+0 3 3 2 3 3 1
+0 1 2 5 1 3 1
+0 3 9 5 5 4 1
+0 2 5 8 1 3 1
+3 2 6 9 4 5 1
+3 0 1 3 3 5 1
+1 3 9 8 1 3 1
+1 2 5 2 2 2 1
+3 2 1 9 5 4 1
+0 2 7 4 5 3 1
+0 1 7 5 5 1 1
+1 0 4 10 1 2 1
+1 2 2 5 5 4 1
+0 3 5 7 1 3 1
+1 3 7 7 3 4 1
+0 2 8 1 4 5 1
+1 2 3 6 4 3 1
+1 3 6 8 3 2 1
+2 1 9 6 2 5 1
+2 1 4 5 4 5 1
+0 2 6 6 3 4 1
+3 0 10 8 1 1 1
+3 2 7 3 4 1 1
+3 0 8 7 5 4 1
+2 1 8 4 5 4 1
+0 1 6 2 1 2 1
+2 3 9 5 5 2 1
+0 3 2 10 4 2 1
+3 1 8 10 2 4 1
+0 3 2 3 3 4 1
+3 2 2 10 2 3 1
+1 0 5 8 3 3 1
+0 1 5 1 3 5 1
+1 0 4 7 3 4 1
+0 1 6 4 4 3 1
+1 0 2 3 3 3 1
+3 1 7 2 4 4 1
+0 1 6 5 1 5 1
+3 2 6 2 1 2 1
+3 1 6 5 5 2 1
+3 1 4 10 1 5 1
+2 3 6 9 4 3 1
+2 1 7 1 3 3 1
+2 3 8 2 3 5 1
+1 3 9 10 3 3 1
+2 3 7 5 1 5 1
+0 1 9 1 5 2 1
+0 1 4 6 1 1 1
+2 1 1 5 1 2 1
+1 3 10 8 3 2 1
+2 3 2 4 3 5 1
+2 3 1 1 1 5 1
+2 1 5 2 4 1 1
+0 2 2 9 4 1 1
+2 0 2 6 1 2 1
+0 1 5 4 3 1 1
+2 1 3 1 4 5 1
+2 3 7 10 1 2 1
+2 1 8 6 2 2 1
+1 0 7 6 4 5 1
+0 1 9 3 5 5 1
+3 1 5 3 5 1 1
+2 0 6 1 3 2 1
+3 2 3 10 4 3 1
+1 0 2 7 2 3 1
+3 0 6 4 5 3 1
+2 3 8 3 4 2 1
+2 3 5 3 1 4 1
+1 2 8 6 2 4 1
+3 2 10 5 5 3 1
+1 3 1 3 3 3 1
+1 2 4 2 3 3 1
+0 2 1 7 3 5 1
+2 3 4 8 4 1 1
+0 1 9 2 4 3 1
+3 1 5 7 1 5 1
+0 2 9 7 1 3 1
+1 2 10 4 1 1 1
+1 3 9 5 2 4 1
+2 3 8 7 4 2 1
+3 0 2 2 2 3 1
+0 2 7 9 1 2 1
+0 3 5 1 5 3 1
+1 2 8 5 2 1 1
+1 0 5 10 3 4 1
+3 2 2 6 5 4 1
+2 1 10 2 1 1 1
+2 0 7 5 5 4 1
\ No newline at end of file
diff --git a/Thread-2/deadlock/data/trivial.in b/Thread-2/deadlock/data/trivial.in
new file mode 100644
index 0000000..ced90d0
--- /dev/null
+++ b/Thread-2/deadlock/data/trivial.in
@@ -0,0 +1,2 @@
+10 10 10 10
+0 1 5 6 3 3 0
\ No newline at end of file
diff --git a/Thread-2/deadlock/lib/resource_manager.cc b/Thread-2/deadlock/lib/resource_manager.cc
index 2231181..97cca6d 100644
--- a/Thread-2/deadlock/lib/resource_manager.cc
+++ b/Thread-2/deadlock/lib/resource_manager.cc
@@ -1,6 +1,8 @@
 #include <mutex>
 #include <thread>
 #include <chrono>
+#include <vector>
+#include <iostream>
 #include <condition_variable>
 #include "resource_manager.h"
 
@@ -9,40 +11,81 @@ namespace proj2 {
 int ResourceManager::request(RESOURCE r, int amount) {
     if (amount <= 0)  return 1;
 
-    std::unique_lock<std::mutex> lk(this->resource_mutex[r]);
-    while (true) {
-        if (this->resource_cv[r].wait_for(
-            lk, std::chrono::milliseconds(100),
-            [this, r, amount] { return this->resource_amount[r] >= amount; }
-        )) {
-            break;
-        } else {
-            auto this_id = std::this_thread::get_id();
-            /* HINT: If you choose to detect the deadlock and recover,
-                     implement your code here to kill and restart threads.
-                     Note that you should release this thread's resources
-                     properly.
-             */
-            if (tmgr->is_killed(this_id)) {
-                return -1;
-            }
-        }
-    }
+    // safe state detect
+    std::unique_lock<std::mutex> lk(this->thread_mutex);
+    this->thread_cv.wait(lk, [this, r, amount]{ return this->safe_detect(std::this_thread::get_id(), r, amount); });
+
+    // update
     this->resource_amount[r] -= amount;
-    this->resource_mutex[r].unlock();
+    this->allocated[std::this_thread::get_id()][r] += amount;
+    this->thread_cv.notify_all();
     return 0;
 }
 
 void ResourceManager::release(RESOURCE r, int amount) {
     if (amount <= 0)  return;
-    std::unique_lock<std::mutex> lk(this->resource_mutex[r]);
+
+    std::thread::id id = std::this_thread::get_id();
+    std::unique_lock<std::mutex> lk(this->thread_mutex);
     this->resource_amount[r] += amount;
-    this->resource_cv[r].notify_all();
+    this->max[id][r] -= amount;
+    this->allocated[id][r] -= amount;
+    if (this->is_complete(id)) {
+        this->max.erase(id);
+        this->allocated.erase(id);
+    }
+    this->thread_cv.notify_all();
 }
 
 void ResourceManager::budget_claim(std::map<RESOURCE, int> budget) {
     // This function is called when some workload starts.
     // The workload will eventually consume all resources it claims
+    std::unique_lock<std::mutex> lk(this->thread_mutex);
+    std::thread::id id = std::this_thread::get_id();
+    this->max[id] = budget;
+}
+
+bool ResourceManager::is_complete(std::thread::id id){
+    for(auto&r: this->max[id])
+        if(r.second != 0) return false;
+    return true;
+}
+
+bool ResourceManager::safe_detect(std::thread::id id, RESOURCE resource, int amount) {
+    if (this->resource_amount[resource] < amount) return false;
+
+    // search safe execution sequence
+    std::map<RESOURCE, int> avail = this->resource_amount;
+    std::map<std::thread::id, std::map<RESOURCE, int>> alloc = this->allocated;
+    std::map<std::thread::id, std::map<RESOURCE, int>> unfinished = this -> max;
+
+    avail[resource] -= amount;
+    alloc[id][resource] += amount;
+
+    while (true) {
+        std::map<std::thread::id, bool> safe;
+        for(auto&th: unfinished){
+            std::thread::id th_id = th.first;
+            safe[th_id] = true;
+            for(auto&r: th.second) {
+                if(alloc[th_id][r.first] + avail[r.first] < r.second){
+                    safe[th_id] = false;
+                    break;
+                }
+            }
+            if (safe[th_id]) {
+                for(auto&r: th.second) {
+                    avail[r.first] += alloc[th_id][r.first];
+                }
+            } else safe.erase(th_id);
+        }
+        for (auto&th: safe){
+            unfinished.erase(th.first);
+        }
+        if (safe.empty()) break;
+    }
+
+    return unfinished.empty();
 }
 
 } // namespace: proj2
diff --git a/Thread-2/deadlock/lib/resource_manager.h b/Thread-2/deadlock/lib/resource_manager.h
index 54b45a6..d789199 100644
--- a/Thread-2/deadlock/lib/resource_manager.h
+++ b/Thread-2/deadlock/lib/resource_manager.h
@@ -4,6 +4,7 @@
 #include <map>
 #include <mutex>
 #include <thread>
+#include <vector>
 #include <condition_variable>
 #include "thread_manager.h"
 
@@ -28,8 +29,15 @@ private:
     std::map<RESOURCE, std::mutex> resource_mutex;
     std::map<RESOURCE, std::condition_variable> resource_cv;
     ThreadManager *tmgr;
+
+    // Banker's Algorithm for Deadlock Prevention
+    std::mutex thread_mutex;
+    std::condition_variable thread_cv;
+    std::map<std::thread::id, std::map<RESOURCE, int>> max, allocated;
+    bool is_complete(std::thread::id);
+    bool safe_detect(std::thread::id, RESOURCE, int);
 };
 
-}  // namespce: proj2
+}  // namespace: proj2
 
 #endif
\ No newline at end of file
